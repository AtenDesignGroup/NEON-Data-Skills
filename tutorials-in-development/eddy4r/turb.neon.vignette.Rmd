---
title: "Example workflow for processing NEON eddy-covariance turbulence data with eddy4R-Docker 0.2.0"
author: "David Durden, Stefan Metzger, Natchaya Pingintha-Durden, Claire Lunch, Megan Jones"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example workflow for processing NEON eddy-covariance turbulence data with eddy4R-Docker 0.2.0}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 0. Install and set up

This vignette assumes you are working with eddy4R within the Docker 
environment established by NEON. To get set up in that environment, 
follow the instructions <a href="https://github.com/NEONScience/NEON-Data-Skills/blob/fbd76ce778bc369fa9b94b7751546abb1ae56073/tutorials/R/eddy4r/dockerEddy4r.md" target="_blank">here</a>.
[CKL: Megan, I put a link to the page on GitHub, because I don't think we've 
put this up on the website yet]

At the end of those instructions, you should have an RStudio 
environment running within Docker. Use that workspace for this 
vignette.

## 1. Install packages and set up environment

First, check for required packages and install any that aren't 
already installed. Once, all required packages are installed they are loaded into the environment.

Throughout this vignette, we use the package::function() 
syntax to explicitly refer to functions. This is done to avoid any 
possibility of ambiguity, in case there are functions in 
different packages with the same name.

[CKL: Dave, based on your feedback, I dropped the update.packages() call. Yes? 
DD: Yes, we should remove the update.packages() call. Otherwise, it will take forever to run the vignette. Plus, we are snapshotting the package versions with to coincide with our eddy4R docker versions going forward. So, any function should work with installed package versions from that release.]

```{r pack-install}

packReq <- c("DataCombine", "eddy4R.base", "eddy4R.qaqc",  "ff", "ffbase", "methods", "rhdf5","splus2R")
lapply(packReq, function(x) {
  print(x)
  if(require(x, character.only = TRUE) == FALSE) {
    install.packages(x)
    library(x, character.only = TRUE)
  }})
base::rm(packReq)

```

Now that we've ensured all needed packages are installed, load 
them:

[CKL: Dave, there are packages in this list that aren't in 
packFlow00 above. Should I add them? 
DD: I thinkg we should add them. I've put them in the list. Additionally, I updated the function to lapply using require. This allowed me to combine the library() call. If you think we should keep separate feel free to revert this change.]


## 2. Set environment variables

Here we set file paths and basic input parameters as environment 
variables for convenience.

[CKL: Dave, I dropped the if(TRUE) on this, because it didn't 
seem useful. Also rearranged a bit and added explanatory 
comments, please review]

```{r env-vars}

# file path for the directory containing input L0' data
base::Sys.setenv("DIRINP" = "/home/eddy/inpExmp")

# file path to the HDF5 file of input L0' data
base::Sys.setenv("DIRFILEPARA" = 
                   "/home/eddy/inpExmp/ECTE_dp0p_CPER_2017-05-01.h5")

# [CKL: this was commented out in the existing vignette. Should I delete? 
# DD: Yeah, we can delete this line]

# file path for outputs
base::Sys.setenv("DIROUT" = "/home/eddy/out")

# date(s) of the input data
# [CKL: is it possible to do this with data spanning multiple days? what's the syntax?
# DD: It is possible, you would just add a vector of ISO formatted date character strings. I suggest we change the name of this variable to DATEOUT. Additionally, the new function actually just searches the input directory for the output date, removing the need for DIRFILEPARA. Do you think we should remove that ENV variable? (It still works with it to)]
base::Sys.setenv("DATEOUT" = "2017-05-01")

# NEON domain of the input data: Domain 10, D10
base::Sys.setenv("FILEOUTBASE" = "NEON.D10.CPER.00200.001")
#[DD: The DOM ENV is no longer needed in the new setup of the function either. We use FILEOUTBASE, which allows us to specify the full beginning of the output filename. I updated it, if you prefer to use the old version let me know]

# NEON site code of the input data:
# Central Plains Experimental Range, CPER
base::Sys.setenv("LOC" = "CPER")
#[DD: We have a function that determines this from the input L0' file now. We can add that function call when we get to reading in Parameters and remove this ENV]

# flag to indicate to the eddy4R.base::def.para.flow() 
# function that the variables above can be found as 
# environment variables, instead of provided as function 
# inputs
base::Sys.setenv("METHPARAFLOW" = "EnvVar")

```

## 3. Read in metadata

[CKL: I'm not sure how to describe this code chunk, because 
it seems a bit redundant with the previous chunk. It looks 
like the idea is to set up the user to use a default file 
if they skipped the previous chunk. I'd be inclined to 
drop it if that's the case.
DD: Yeah, exactly. There is a file on dropbox that will be read by default if the ENV variables are not specified. We can remove this if you think it is better.
]

```{r metadata}

# start with an empty list of parameters
Para <- base::list()

# [CKL: Again, I'm confused here. We're confirming that we 
# entered the environment variable we just entered above. 
# Also, why set MethParaFlow both in the environment 
# variables AND in the function call? Isn't the idea of 
# the environment variables option to avoid this?]
# [DD: Yeah, this function grabs all the workflow parameters from the ENV or sets them to default values. This was taken from the workflow we use for L1 transitions, so we built in capabilities to specify function argument directly, through ENV variables from within RStudio or from the command line, or not specify anything and run the gold file test. So, a lot of this can be removed.]

  Para$Flow <- eddy4R.base::def.para.flow(MethParaFlow = "EnvVar")


```







[CKL: everything below comes with the vignette template, I 
kept it for my own reference, will delete in final version]

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
