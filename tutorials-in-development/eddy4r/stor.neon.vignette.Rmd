---
title: "Example workflow for processing NEON eddy-covariance storage data with eddy4R-Docker 0.2.0"
author: "Ke Xu, Natchaya Pingintha-Durden, David Durden, Stefan Metzger"
date: "11/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 0. Install and set up

This vignette assumes you are working with eddy4R within the Docker 
environment established by NEON. To get set up in that environment, 
follow the instructions <a href="neonscience.org/set-up-docker" target="_blank">here</a>.

At the end of those instructions, you should have an RStudio 
environment running within Docker. Use that workspace for this 
vignette.





## 1. Install packages and set up environment

First, check for required packages and install any that aren't 
already installed. Once all required packages are installed, 
load them into the environment.

Throughout this vignette, we use the `package::function()` 
syntax to explicitly refer to functions. This is done to avoid any 
possibility of ambiguity, in case there are functions in 
different packages with the same name.



```{r pack-install,  message=F, warning=F}


# load and attach required  packages
#Call the R HDF5 Library
packReq <- c("Hmisc")

lapply(packReq, function(x) {
  print(x)
  if(require(x, character.only = TRUE) == FALSE) {
    utls::install.packages(x)
    library(x, character.only = TRUE)
  }})
#Remove workflow package list
rm(packReq)

# load and attach packages
library(DataCombine)
library(eddy4R.base)
library(eddy4R.turb)
library(ff)           # need to be loaded and attached for arithmetic to work properly on ff objects
library(ffbase)       # need to be loaded and attached for arithmetic to work properly on ff objects
# the default for Rscript (and apparently R CMD BATCH) omits package "methods"
# (https://stat.ethz.ch/R-manual/R-devel/library/utils/html/Rscript.html)
# this in turn brakes splus2R calls (...could not find function "is"...)
# hence, exlicitly load and attach package 'methods'
library(methods)
library(rhdf5)
library(Hmisc)

```



## 2. Set environment variables and read in metadata

Here we set file paths and basic input parameters as environment 
variables for convenience.


```{r env-vars}

# define global environment
eddy4R.base::def.env.glob()

# Start logging
logLevel <- Sys.getenv('LOG_LEVEL')
if (is.null(logLevel) || logLevel == "") {
    assign("rlog", NEONprocIS.base::def.log.init(Lvl="debug"), envir = .GlobalEnv)
} else {
    assign("rlog", NEONprocIS.base::def.log.init(), envir = .GlobalEnv)
}
rlog$info("Start ECSE L1 daily transition from flow.stor.towr.neon.R")



# File path for the directory containing input L0' data 
if(FALSE) {
  # set to FALSE if not under developement
  base::Sys.setenv("DEVE" = "FALSE")
  # base::Sys.setenv("DIRFILEPARA" = paste0("/home/", Sys.getenv("USER"), "/eddy/data/storTowr/inpRefe/ECSE_dp0p_KONZ_2017-09-05.h5"))
  base::Sys.setenv("DIRINP" = paste0("/home/", Sys.getenv("USER"), "/eddy/data/irga/inpRefe/KONZ/ECSE"))
  base::Sys.setenv("DIRMNT" = paste0("/home/", Sys.getenv("USER"), "/eddy"))
  base::Sys.setenv("DIROUT" = paste0("/home/", Sys.getenv("USER"), "/eddy/data/irga/outRefe/KONZ"))
  # adjust depending on whether dp01 / dp04 output; site name
  base::Sys.setenv("FILEOUTBASE" = "ECSE_dp04_KONZ")
  base::Sys.setenv("DATEOUT" = "2018-11-28")
  base::Sys.setenv("METHPARAFLOW" = "EnvVar")
  base::Sys.setenv("VERSDP" = "001")
}


Para <- list()

# check environment variables for eddy4R workflow parameter "DirFilePara"
if("METHPARAFLOW" %in% base::names(base::Sys.getenv())) {

  Para$Flow <- eddy4R.base::def.para.flow(MethParaFlow = "EnvVar")

  # in case no dp0p h5 file is specified for parameters, download gold files and assign corresponding DirFilePara
} else {

  #The dates for the run must be specified, this set is for the gold file
  DateOut<- "2018-11-28" #Should talk to Stefan about best way to handle this
  FileOutBase <- "ECSE_dp04_KONZ"
  Para$Flow <- eddy4R.base::def.para.flow(DateOut = DateOut, FileOutBase = FileOutBase, MethParaFlow = "DfltInp",
    UrlInpRefe = "https://s3.data.neonscience.org/neon-ec-goldfiles/EC-storage-processing/inpRefeStor_20190708.zip",
    UrlOutRefe = "https://s3.data.neonscience.org/neon-ec-goldfiles/EC-storage-processing/outRefeStor_20190708.zip")
}



#--------------------------------------------------------------------------------------------
# ASSEMBLE PARAMETERS FROM HDF5 FILE

# create list for parameters; c2r == copied to GitHub parameter repo

# Grab the NEON specific 4-letter code for the site location (Loc) from the dp0p input file
Para$Flow$Loc <- eddy4R.base::def.para.site(FileInp = Para$Flow$DirFilePara)$Loc

#Grab the tower top level
Para$Flow$LvlTowrTop <- eddy4R.base::def.para.site(FileInp = Para$Flow$DirFilePara)$LvlTowr
Para$Flow$LvlTowrTop <- Para$Flow$LvlTowrTop[length(Para$Flow$LvlTowrTop)]

#Use the definition function to grab reingest data
#indicating which data will be grab
if (Para$Flow$Deve == TRUE) {
  DpName <- c("tempAirLvl", "tempAirTop", "fluxHeatSoil", "radiNet", "presBaro") } else {
    DpName <- c("tempAirLvl", "tempAirTop", "fluxHeatSoil", "radiNet", "tempSoil", "h2oSoilVol", "presBaro")
  }

#list all group hdf5 path before adding the exixting data
listParaPre <- rhdf5::h5ls(Para$Flow$DirFilePara, datasetinfo = FALSE)

#get the Para$Flow$dp01Exis$Lvl for each dp
Para$Flow$dp01Exis$Lvl <- list()
for (i in 1:length(DpName)){
  nameSens <- paste0("/", Para$Flow$Loc, "/dp01/data/", DpName[i])
  tmpLvl <- listParaPre$name[which(listParaPre$group %in% nameSens)]
  #get rid of averaging period
  tmpLvl <- grep(pattern = "30m", x = tmpLvl, ignore.case = TRUE, value =  TRUE)
  tmpLoc <- strsplit(as.character(tmpLvl),split='_', fixed=TRUE)
  Para$Flow$dp01Exis$Lvl[[DpName[i]]] <- unlist(lapply(1:length(tmpLoc), function(x) {as.character(paste0(tmpLoc[[x]][1], "_", tmpLoc[[x]][2]))}))
}

rlog$debug("Begin to re-ingest the existing dp01 data")
base::invisible(eddy4R.base::wrap.hdf5.wrte.dp01.api(date = Para$Flow$DateOut, SiteLoca = Para$Flow$Loc, FileOut = Para$Flow$DirFilePara, LvlTowr = Para$Flow$dp01Exis$Lvl, DpName = DpName))
rlog$info("End of re-ingest the existing dp01 data")
# workflow parameters




#--------------------------------------------------------------------------------------------
# TO BE LOADED

# set directories / pathes

#  working directory


# default: use temporary working directory on Docker filesystem
if(is.na(Para$Flow$DirWrk)) {

  Para$Flow$DirWrk <- tempdir()

  # option: create user-specified working directory, e.g. on host filesystem
} else {

  dir.create(Para$Flow$DirWrk, recursive = TRUE, showWarnings = FALSE)

}

# set working directory
setwd(Para$Flow$DirWrk)

#  DirInp, DirMnt input directory

# default: use temporary working directory on Docker filesystem
if(is.na(Para$Flow$DirInp)) {

  Para$Flow$DirInp <- paste0(Para$Flow$DirWrk, "/inpRefe")

  # option: create user-specified input directory (if not existing), e.g. on host filesystem
} else {

  dir.create(Para$Flow$DirInp, recursive = TRUE, showWarnings = FALSE)

}

#  output directory

# default: use temporary working directory on Docker filesystem
if(is.na(Para$Flow$DirOut)) {

  Para$Flow$DirOut <- paste0(Para$Flow$DirWrk, "/out")

  # option: create user-specified input directory (if not existing), e.g. on host filesystem
} else {

  dir.create(Para$Flow$DirOut, recursive = TRUE, showWarnings = FALSE)

}


Para$Flow$Site <- edd4R.base::def.hdf5.read.para(
  DirFileParaLoca = Para$Flow$DirFilePara,
  GrpName = paste0("/", Para$Flow$Loc)#,
  #SetPara = c("PrdIncrAgrDflt", "PrdWndwAgrDflt")
)

#read in L0p parameters setup-------------------------------------------------------------------


DespLoca <- list()
#de-spiking median filter window width [s]
DespLoca$widt <- 9

#de-spiking histogram bins initial number/step size
DespLoca$nbin <- 2

#de-spiking resolution threshold
DespLoca$rest <- 10

# sensors and variables for which to perform de-spiking
#DespLoca$var <- sapply(base::names(Rng), function(x) base::names(Rng[[x]]))
DespLoca$var <- list()

DespLoca$var$irgaStor <- c("asrpCo2", "asrpH2o", "pres", "rtioMoleDryCo2","rtioMoleDryH2o", "rtioMoleWetCo2", "rtioMoleWetH2o", "temp")
DespLoca$var$mfcSampStor <- c("frt", "frt00", "frtSet00", "presAtm", "temp")
DespLoca$var$mfcValiStor <- DespLoca$var$mfcSampStor
DespLoca$var$crdCo2 <- c("dlta13CCo2", "pres",       "rtioMoleDry12CCo2", "rtioMoleDry13CCo2", "rtioMoleDryCo2",    "rtioMoleDryH2o",  "rtioMoleWet12CCo2", "rtioMoleWet13CCo2", "rtioMoleWetCo2", "rtioMoleWetH2o", "temp",           "tempWbox")
DespLoca$var$crdH2o <- c("rtioMoleWetH2o", "rtioMoleDryH2o", "dlta18OH2o",     "dlta2HH2o", "temp",  "pres")
DespLoca$var$crdH2oValvVali <- "injNum"
DespLoca$var$envHut <- c("rtioMoleWetH2o", "rh",             "temp" ,          "pres"   )
DespLoca$var$mfm <- c("frt", "frt00", "presAtm", "temp")
DespLoca$var$presInlt <-c("presDiff")
DespLoca$var$presValiRegInStor <- c("presDiff")
DespLoca$var$presValiRegOutStor <- c("presDiff")
# map parameters (workflow and scientific) to internal process



#freq output for all data products
#unit [min]
resoTimeDp01 <- list(
  "co2Stor" = c(2, 30) * 60, #output node in dp01
  "h2oStor" = c(2, 30) * 60,  #output node in dp01
  "tempAirLvl" = c(1,  30) * 60,  #output node in dp01
  "tempAirTop" = c(1, 30) * 60,  #output node in dp01
  "isoCo2" = c(9, 30) * 60,  #output node in dp01
  "isoH2o" = c(3, 9, 30) * 60,  #output node in dp01
  "irgaStor" = c(2, 30) * 60, #sensor
  "mfcSampStor" = c(2, 30) * 60, #sensor
  "mfcValiStor" = c(2, 30) * 60, #sensor
  "mfm" = c(2, 30) * 60 #sensor
)







MapSensDp01 <- list(
  "co2Stor" = "irgaStor",
  "h2oStor" = "irgaStor",
  "isoCo2" = "crdCo2",
  "isoH2o" = "crdH2o"
)

#list all group hdf5 path
listPara <- rhdf5::h5ls(Para$Flow$DirFilePara, datasetinfo = FALSE)

#adding the logic if there is no sensor in dp0p
inpSens <- c("irgaStor", "mfcSampStor", "mfcValiStor", "irgaValvLvl",
             "crdCo2", "crdH2o", "crdH2oValvVali", "crdCo2ValvLvl", "crdH2oValvLvl", "envHut", "valvAux", "mfm")
#additional sensors
addSens <- c("presInlt", "presValiRegInStor", "presValiRegOutStor", "pumpStor", "rhSens")
#logic to state if this workflow includes the additional sensors sensors
#need to delete if all sensors are in the input file
LocAddSens <- TRUE
if (LocAddSens == TRUE) inpSens <- c(inpSens, addSens)

#define dp0p sensor names which related to dp01 to dp04 generation
Sens <-c()
for (i in 1:length(inpSens)){
  if((paste0("/", Para$Flow$Loc, "/dp0p/data/", inpSens[i]) %in% listPara$group)) Sens[i] <- inpSens[i]
}

# principal sampling frequency, used for resampling
#  ParaSens$SensFreqSamp
# unit [Hz]
#get all sensors that have data in dp0p
Sens <- c(Sens)
#get rid of NA
Sens <- Sens[!is.na(Sens)]

#get parameter of sensor frequency
Para$Flow$dp0p <- list()
for(idxSens in Sens){
  Para$Flow$dp0p[[idxSens]] <- list()
  Para$Flow$dp0p[[idxSens]]$FreqSamp <- edd4R.base::def.hdf5.read.para(
    DirFileParaLoca = Para$Flow$DirFilePara,
    GrpName = paste0("/", Para$Flow$Loc, "/dp0p/data/", idxSens)#,
    #SetPara = c("PrdIncrAgrDflt", "PrdWndwAgrDflt")
  )$FreqSamp

  # The input frequency is the sensor frequency, including the parameter of frequency such as ~1 and varies in crdCo2 and crdH2o, and 0.2 in valvAux, but the actual dp0p data frequency is already adjusted to 1 Hz in dp0p, therefore, here we adjust freqSamp to 1
  # This is just short-term workaround, will need to change in L0p data products, and ultimately sensor frequency should be read in from dp0p automatically
  Para$Flow$dp0p[[idxSens]]$FreqSamp <- 1


}


#get the Para$Flow$dp01$LvlTowr for each sensor
Para$Flow$dp01$LvlTowr <- list()
for (i in 1:length(Sens)){
  nameSens <- paste0(Sens[i], "/")
  Para$Flow$dp01$LvlTowr[[Sens[i]]] = unique(sapply(1:length(unique(listPara$group[(grep(nameSens,listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep(nameSens,listPara$group))]), nameSens)[[xx]][2]))
}

Para$Flow$dp01$LvlTowr$co2Stor <- Para$Flow$dp01$LvlTowr$irgaStor #output in dp01
#"000_010" "000_020" "000_030" "000_040" "co2Arch" "co2High" "co2Low"  "co2Med"  "co2Zero"
Para$Flow$dp01$LvlTowr$h2oStor <- Para$Flow$dp01$LvlTowr$irgaStor # output in dp01
#"000_010" "000_020" "000_030" "000_040" "co2Arch" "co2High" "co2Low"  "co2Med"  "co2Zero"
Para$Flow$dp01$LvlTowr$isoCo2 <- Para$Flow$dp01$LvlTowr$crdCo2
Para$Flow$dp01$LvlTowr$isoH2o <- Para$Flow$dp01$LvlTowr$crdH2o

```

## 3. Read in data!

Pass along the environment variables defined in section 2, 
then read in additional parameters from the HDF5 file.

We have found in testing that this section may run into trouble if 
Docker is not assigned sufficient memory in your system. If you 
find that this section hangs or errors out, try opening 
Docker -> Preferences -> Advanced and increasing the memory 
allotment.

```{r ingest,  message=F, warning=F}

numDate <- 0
tmpOut <- list()
# assign list
Data <- list()
qfqmFlag <- list()

# start loop around dates
for(Date in Para$Flow$DateOut) {
  rlog$debug(paste0("dataset ", Date, " DP0p read in begins!"))
  numDate <- numDate + 1


  # begin: read raw data
  if(Para$Flow$Read == "hdf5") {
    ###

    ##############################################################################################
    #Data IMPORT

    # assign list for inputs
    inp <- list()

    # start loop around instruments
    for(idxSens in Sens){
     
      for(idxLvl in Para$Flow$dp01$LvlTowr[[idxSens]]){
        # call read-in wrapper, assign result as temporary variable
        tmp <- eddy4R.base::wrap.hdf5.read(
          DirInpLoca = Para$Flow$DirInp,
          SiteLoca = Para$Flow$Loc,
          DateLoca = Date,
          VarLoca = idxSens,
          FreqLoca = Para$Flow$dp0p[[idxSens]]$FreqSamp, #"~1"
          LvlTowr = idxLvl,
          #RngLoca = Rng[[idxSens]],
          DespLoca = DespLoca,
          MethMeas = "ecse"
        )


        #Read in quality flags from HDF5 file
        if(!idxSens %in% c("irgaValvLvl", "crdH2oValvVali", "crdCo2ValvLvl", "crdH2oValvLvl")){

          tmpQfqm <- eddy4R.base::def.hdf5.read.qfqm(
            DirInpLoca = Para$Flow$DirInp,
            SiteLoca = Para$Flow$Loc,
            DateLoca = Date,
            VarLoca = idxSens,
            FreqLoca = Para$Flow$dp0p[[idxSens]]$FreqSamp,
            LvlTowr = idxLvl,
            MethMeas = "ecse"
          )

          #Remove time from set of flags
          tmpQfqm <- tmpQfqm[,grep("time",names(tmpQfqm),invert = T), drop = FALSE]

        }

        # assign result as ffdf to inp

        # time domain incl. unit assignment
        if(idxSens %in% c("irgaStor","crdCo2","crdH2o")) {

          inp$time <- tmp$time
          #ff::as.ffdf.data.frame(data.frame(UTC = tmp$time))
          base::attr(x = inp$time, which = "unit") <- "YYYY-MM-DD hh:mm:ss.sss"

        }

        # sensor data incl. unit assignment
        inp$data[[idxSens]][[idxLvl]] <- tmp$data
        #ff::as.ffdf.data.frame(tmp$data)
        for(idx in base::names(tmp$data)) base::attr(x = inp$data[[idxSens]][[idxLvl]][[idx]], which = "unit") <-
          base::attr(x = tmp$data, which = "unit")[[idx]]
        if(exists("tmpQfqm")) inp$qfqm[[idxSens]][[idxLvl]] <- data.frame(tmpQfqm)

        # clean up
        rm(tmp)
        if(exists("tmpQfqm")) rm(tmpQfqm)
        invisible(gc())

        # end loop around instruments
      }#; rm(idxLvl)
    }#; rm(idxSens)

    # Perform daily processing in native resolution
    # actual calculation
    inp <- eddy4R.stor::wrap.prd.day.ecse(
      inpList = inp,
      Desp = DespLoca
    )

    rlog$debug(paste0("dataset ", Date, ": perform daily processing in native resolution"))


    ###
    # mid: read raw data
  } else {
    rlog$debug(paste0("dataset ", Date, " loading pre-processed raw data begin"))
    ###



    # load pre-processed high-frequency data from daily file

    # assign input data list
    inp <- list()

    # start loop around instruments
    for(idxSens in c("irgaStor", "mfcSampStor", "soni", "soniAmrs", "time")){
      # load from file
      ffload(file = paste(Para$Flow$DirWrk, "/", Para$Flow$Loc, "/", Para$Flow$VersDp, "/30-min rawdata/rawdata_", Date, "_", idxSens, sep=""), overwrite = TRUE)

      # assign to inp list
      inp$data[[idxSens]] <- tmp

      # clean up
      rm(tmp)
      invisible(gc())

      # end loop around instruments
    }; rm(idxSens)



    ###
    rlog$debug(paste0("dataset ", Date, " loading pre-processed raw data complete"))
  }
  # end: read raw data
  ###



  # assign daily data and attributes to file-backed objects; RAM 2.8 GB

  # case #1: first day (creation)
  if(numDate == 1) {

    for(idxSens in Sens){
      Data[[idxSens]] <- inp$data[[idxSens]]
      qfqmFlag[[idxSens]] <- inp$qfqm[[idxSens]]
    }

    # time objects
    Data$time <- inp$time
    qfqmFlag$time <- inp$time

    # case #2: subsequent day (appending)
  } else {

    for(idxSens in Sens){
      Data[[idxSens]] <- rbind(Data[[idxSens]], inp[[idxSens]])
      qfqmFlag[[idxSens]] <- rbind(qfqmFlag[[idxSens]], inp$qfqm[[idxSens]])
    }

    Data$time <- rbind(Data$time, inp$time)
    qfqmFlag$time <- rbind(qfqmFlag$time, inp$time)

  
  }

  # clean up
  inp <- NULL
  invisible(gc())

}
# end: loop around Dates


rlog$info(paste0("dataset ", Date, " dp0p read in finishes!"))



```




## 4. eddy-covariance storage exchange (ECSE) level 1 data products (dp01) generation.

The first step is to get indixes for different temporal resolutions at level 1 data products to determine where valid sampling and validation data are, using eddy4R.base::def.idx.agr(). 
Then the descriptive statistics, mean, minimum, maximum, variance, standard deviation, number of samples, as well as begin time and end time are calculated at different temporal resolutions as a list of data.frames, using eddy4R.stor::wrap.dp01.ecse(). 
eddy4R.qaqc::wrap.dp01.qfqm.ecse() and eddy4R.ucrt::wrap.neon.dp01.ucrt.ecse() are used to calculate quality and uncertatiny metrics. 
Then concatenate results and HDF5 data formatting.



```{r dp01-process,  message=F, warning=F}

rlog$debug(paste0("dataset ", Date, " dp01 calculation begin"))

# assign list for masked input data and parameters
wrk <- list()

#determine which entries in Data correspond to desired aggregation interval


wrk$setData <- list()
for(idxFreq in c(1, 2, 30)){

  tmpIdx <- eddy4R.base::def.idx.agr(
    time = 1:86400,
    PrdAgr = (idxFreq * 60),
    FreqLoca = 1,
    MethIdx = "rglr"
  )

  wrk$setData[[paste0(idxFreq, "min")]]$Bgn <- tmpIdx$idxBgn
  wrk$setData[[paste0(idxFreq, "min")]]$End <- tmpIdx$idxEnd

}


# assign list
# for dp01 output
wrk$dp01 <- list()
wrk$qfqmOut <- list()
wrk$ucrt <- list()

  # c2r: VersDp output version
  Para$Flow$VersDp <- paste0(Para$Flow$VersDp, "_", format(Sys.time(), "%Y%m%d_%H%M%S_%Z"))


  #Input parameter for different sensors in dp01 data processing
  Para$Flow$dp01$Inp <- list()
  
  # for co2Stor during sampling period
  Para$Flow$dp01$Inp$data$co2Stor$samp <- list(
    "lvlMfcSampStor" = Para$Flow$dp01$LvlTowr$mfcSampStor,
    "lvlMfcValiStor" = NULL,
    "lvlValv" = Para$Flow$dp01$LvlTowr$irgaValvLvl,
    "PrdMeas" = 2,
    "lvlCrdH2oValvVali" = NULL
  )

  # for co2Stor during validating period
  Para$Flow$dp01$Inp$data$co2Stor$vali <- list(
    "lvlMfcSampStor" = Para$Flow$dp01$LvlTowr$mfcSampStor,
    "lvlMfcValiStor" = Para$Flow$dp01$LvlTowr$mfcValiStor,
    "lvlValv" = Para$Flow$dp01$LvlTowr$irgaValvLvl,
    "PrdMeas" = 2,
    "lvlCrdH2oValvVali" = NULL
  )

  #for h2oStor
  Para$Flow$dp01$Inp$data$h2oStor <- Para$Flow$dp01$Inp$data$co2Stor

  # for isoCo2 during sampling period
  Para$Flow$dp01$Inp$data$isoCo2$samp <- list(
    "lvlMfcSampStor" = NULL,
    "lvlMfcValiStor" = NULL,
    "lvlValv" = Para$Flow$dp01$LvlTowr$crdCo2ValvLvl,
    "PrdMeas" = 9,
    "lvlCrdH2oValvVali" = NULL
  )

  # for isoCo2 during validating period
  Para$Flow$dp01$Inp$data$isoCo2$vali <- list(
    "lvlMfcSampStor" = NULL,
    "lvlMfcValiStor" = Para$Flow$dp01$LvlTowr$mfcValiStor,
    "lvlValv" = NULL,
    "PrdMeas" = 9,
    "lvlCrdH2oValvVali" = NULL
  )

 # for isoH2o during sampling period
  Para$Flow$dp01$Inp$data$isoH2o$samp <- list(
    "lvlMfcSampStor" = NULL,
    "lvlMfcValiStor" = NULL,
    "lvlValv" = Para$Flow$dp01$LvlTowr$crdH2oValvLvl,
    "PrdMeas" = 9,
    "lvlCrdH2oValvVali" = NULL
  )

  
  # for isoH2o during validating period
  Para$Flow$dp01$Inp$data$isoH2o$vali <- list(
    "lvlMfcSampStor" = NULL,
    "lvlMfcValiStor" = NULL,
    "lvlValv" = NULL,
    "PrdMeas" = 3,
    "lvlCrdH2oValvVali" = Para$Flow$dp01$LvlTowr$crdH2oValvVali
  )



  #Input parameter for qfqm in dp01
  Para$Flow$dp01$Inp$qfqm <- list()

  for (idxTmp in names(Para$Flow$dp01$Inp$data)){
    Para$Flow$dp01$Inp$qfqm[[idxTmp]]$samp$lvlValvAux <- NULL
    Para$Flow$dp01$Inp$qfqm[[idxTmp]]$vali$lvlValvAux <- NULL
  }

  Para$Flow$dp01$Inp$qfqm$co2Stor$samp$lvlValvAux <- Para$Flow$dp01$LvlTowr$valvAux
  Para$Flow$dp01$Inp$qfqm$co2Stor$vali$lvlValvAux <- Para$Flow$dp01$LvlTowr$valvAux
  Para$Flow$dp01$Inp$qfqm$h2oStor <- Para$Flow$dp01$Inp$qfqm$co2Stor


  #Input parameter for ucrt in dp01
  Para$Flow$dp01$Inp$ucrt <- Para$Flow$dp01$Inp$data
  Para$Flow$dp01$Inp$ucrt$isoCo2$vali$lvlValv <- Para$Flow$dp01$LvlTowr$crdCo2ValvLvl



  #select data for different sampling, validating data at different window size (1 min, 2 min, 3 min, 9 min)
  for(idxDp01 in names(Para$Flow$dp01$Inp$data)){

    #adding logic to run if there is the sensor data in dp0p
    if(MapSensDp01[[idxDp01]] %in% Sens){
      for(idxLvl in Para$Flow$dp01$LvlTowr[[idxDp01]]){

        #determine different PrdAgr
        PrdAgr <- as.integer(resoTimeDp01[[idxDp01]]/60)

        #determine sampling or validating data
        if (substring(idxLvl, 1, 3) == "000"){
          tmpTypeMeas <- "samp"
          if(idxDp01 == "isoH2o" ) PrdAgr <- as.integer(resoTimeDp01[[idxDp01]][c(2,3)]/60)


        } else {
          tmpTypeMeas <- "vali"
          if(idxDp01 == "isoH2o" ) PrdAgr <- as.integer(resoTimeDp01[[idxDp01]][c(1,3)]/60)

        }


        for (idxPrdAgr in PrdAgr) {
          tmpDp01 <- list()
          tmpQfqmDp01 <- list()
          #dp01 processing
          rlog$debug(paste0("dataset ", Date, ": dp01 data processing ", idxDp01, " dp01 at measurment level of ", idxLvl))
          tmpDp01 <- eddy4R.stor::wrap.dp01.ecse(dp01 = idxDp01,
                                                 lvl = idxLvl,
                                                 lvlMfcSampStor = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlMfcSampStor, #Para$Flow$dp01$LvlTowr$mfcSampStor,
                                                 lvlEnvHut = Para$Flow$dp01$LvlTowr$envHut,
                                                 lvlValv = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlValv,
                                                 lvlCrdH2oValvVali = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlCrdH2oValvVali,
                                                 data = Data,
                                                 qfInp = qfqmFlag,
                                                 TypeMeas = tmpTypeMeas,
                                                 PrdMeas = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$PrdMeas,
                                                 PrdAgr = idxPrdAgr,
                                                 idxTime = wrk$setData
          )
          #qfqm processing
          rlog$debug(paste0("dataset ", Date, ": dp01 qfqm processing ", idxDp01, " dp01 for ", idxLvl))
          tmpQfqmDp01 <- eddy4R.qaqc::wrap.dp01.qfqm.ecse(dp01 = idxDp01,
                                                          RptExpd = TRUE,
                                                          lvl = idxLvl,
                                                          lvlMfcSampStor = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlMfcSampStor, #Para$Flow$dp01$LvlTowr$mfcSampStor,
                                                          lvlMfcValiStor = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlMfcValiStor,
                                                          lvlEnvHut = Para$Flow$dp01$LvlTowr$envHut,
                                                          lvlValv = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlValv,
                                                          lvlCrdH2oValvVali = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlCrdH2oValvVali,
                                                          lvlValvAux = Para$Flow$dp01$Inp$qfqm[[idxDp01]][[tmpTypeMeas]]$lvlValvAux,
                                                          data = Data,
                                                          qfInp = qfqmFlag,
                                                          TypeMeas = tmpTypeMeas,
                                                          PrdMeas = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$PrdMeas,
                                                          PrdAgr = idxPrdAgr,
                                                          idxTime = wrk$setData
          )
          #ucrt processing
          rlog$debug(paste0("dataset ", Date, ": dp01 ucrt processing ", idxDp01, " dp01 for", idxLvl))
          tmpUcrtDp01 <- eddy4R.ucrt::wrap.neon.dp01.ucrt.ecse(dp01 = idxDp01,
                                                               lvl = idxLvl,
                                                               lvlMfcSampStor = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$lvlMfcSampStor, #Para$Flow$dp01$LvlTowr$mfcSampStor,
                                                               lvlEnvHut = Para$Flow$dp01$LvlTowr$envHut,
                                                               lvlValv = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$lvlValv,
                                                               lvlCrdH2oValvVali = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$lvlCrdH2oValvVali,
                                                               data = Data,
                                                               qfInp = qfqmFlag,
                                                               TypeMeas = tmpTypeMeas,
                                                               PrdMeas = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$PrdMeas,
                                                               PrdAgr = idxPrdAgr,
                                                               idxTime = wrk$setData
          )
          #rename idxLvl
          idxLvLPrdAgr <- paste0(idxLvl, "_", sprintf("%02d", idxPrdAgr), "m")
          #output calculate dp01, qfqm, and ucrt
          wrk$dp01[[idxDp01]][[idxLvLPrdAgr]] <- tmpDp01
          wrk$qfqmOut[[idxDp01]][[idxLvLPrdAgr]] <- tmpQfqmDp01
          wrk$ucrt[[idxDp01]][[idxLvLPrdAgr]] <- tmpUcrtDp01
          # clean up
          base::invisible(base::gc())
        }#close idxPrdAgr

      }# end of loop around idxLvl
    }# end of whether there is a valid data
  }# end of loop around idxDp01




  # clean up

  invisible(gc())

  # concatenate results and HDF5 data formatting-----------------------------------------------------------------------------------------

  # create directory
  #dir.create(paste0(Para$Flow$DirOut, "/", Para$Flow$Loc, "/", Para$Flow$VersDp), showWarnings = FALSE)
  #combine data product output into rpt
  rpt <- list()
  rpt$dp01$data <- eddy4R.base::def.hdf5.pack(inpList=wrk$dp01, MethMeas = "ecse", Dp ="Dp01")
  rpt$dp01$qfqm <- eddy4R.base::def.hdf5.pack(inpList=wrk$qfqmOut, MethMeas = "ecse", Dp ="Dp01")
  rpt$dp01$ucrt <- eddy4R.base::def.hdf5.pack(inpList=wrk$ucrt, MethMeas = "ecse", Dp ="Dp01")
  # add standard error under /ucrt
  for(idxDp01 in c("co2Stor", "h2oStor", "isoCo2", "isoH2o")){
    for(idxLvl in base::names(rpt$dp01$ucrt[[idxDp01]])){
     
      for(idxSub in base::names(rpt$dp01$ucrt[[idxDp01]][[idxLvl]])){
       
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$se <- rpt$dp01$data[[idxDp01]][[idxLvl]][[idxSub]]$se
        #re-arrange order of variable
        tmp <- data.frame(mean= rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$mean,
                          vari = rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$vari,
                          se = rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$se,
                          timeBgn = as.character(rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$timeBgn),
                          timeEnd = as.character(rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$timeEnd))
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[1]] <- tmp$mean
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[2]] <- tmp$vari
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[3]] <- tmp$se
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[4]] <- as.character(tmp$timeBgn)
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[5]] <- as.character(tmp$timeEnd)
        names(rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]) <- names(tmp)
      };rm(tmp)
    }
  }

  #transfer units
  for(idxDp in base::names(rpt$dp01$data)) {
    for(idxLvl in base::names(rpt$dp01$data[[idxDp]])){
      for(idxVar in base::names(rpt$dp01$data[[idxDp]][[idxLvl]])){
       
        #Add a fix here to remove se in /data
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$se <- NULL

        #unit transfer
        base::attr(x = rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]], which = "unit") <-
          base::attr(x = wrk$dp01[[idxDp]][[idxLvl]][[1]]$mean[[idxVar]], which = "unit")


      }
    }

  }; rm(idxVar)

  #qfqm transfer units
  for(idxDp in base::names(rpt$dp01$qfqm)) {
  
    for(idxLvl in base::names(rpt$dp01$qfqm[[idxDp]])){
      for(idxVar in base::names(rpt$dp01$qfqm[[idxDp]][[idxLvl]])){
        #unit transfer
        attributes(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <-
          attributes(wrk$qfqmOut[[idxDp]][[idxLvl]][[1]]$qfFinl[[idxVar]])$unit


      }
    }

  }; rm(idxVar)


  # end loop around aggregation interval
  rlog$info(paste0("dataset ", Date, " dp01 calculation complete!"))
  #save.image(wrk$dp01, file="~/wrkdp01_object.RData")
  save.image("~/wrkdp01.RData")
  
```




## 5. ECSE level 2 data products (dp02) generation.

First read in ECSE level 1 temperature data; 
Then intepolate ECSE level 1 IRGA gas data and temperature data into continuous minutely data, using eddy4R.stor::def.itpl.time(); 
Then also intepolate ECSE Level 1 qfqm data; 
Then calcualte the time change rate, using eddy4R.stor::def.time.rate.diff();
Then concatenate results and HDF5 data formatting.



```{r dp02-process,  message=F, warning=F}

rlog$debug(paste0("dataset ", Date, " dp02 calculation begin"))
  FileInp <- Para$Flow$DirFilePara
  ## read in exiting dp01 data from input dp0p hdf5 file
  #List of all object names
  listObjName <- base::paste(listPara$group, listPara$name, sep = "/")

  ##Groups for HDF5 group structure
  #Grabbing just the HDF5 groups
  listGrp <- listPara[listPara$otype == "H5I_GROUP",]

  listGrpName <- base::paste(listGrp$group, listGrp$name, sep = "/")

  ##Dataset for HDF5 dataset output
  #Grab just the data objects
  listDataObj <- listPara[listPara$otype == "H5I_DATASET",]

  #Combining names for grabbing datasets
  listDataName <- base::paste(listDataObj$group, listDataObj$name, sep = "/")

  #get LvlTowr
  Para$Flow$dp01$LvlTowr$tempAirLvl <- unique(sapply(1:length(unique(listPara$group[(grep("tempAirLvl/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirLvl/",listPara$group))]), "tempAirLvl/")[[xx]][2]))
  Para$Flow$dp01$LvlTowr$tempAirTop <- unique(sapply(1:length(unique(listPara$group[(grep("tempAirTop/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirTop/",listPara$group))]), "tempAirTop/")[[xx]][2]))

  exitDp01 <- c("tempAirLvl", "tempAirTop")
  #get sub dp01
  exitSubDp01 <- list()
  for(idxDp in exitDp01) {
    subName <- unique(listPara$group[(grep(paste0(idxDp, "/"),listPara$group))])[1]
    exitSubDp01[[idxDp]] <- listDataObj$name[listDataObj$group == subName]
  }
  #assign data into rpt
  for(idxDp in exitDp01) {
   
    for(idxLvl in Para$Flow$dp01$LvlTowr[[idxDp]]){
      for(idxVar in exitSubDp01[[idxDp]]){
        #get /CPER/dp01/data
        #Combining names for grabbing datasets
        listDataNameTmp <- paste0("/",Para$Flow$Loc, "/", "dp01", "/", "data", "/", idxDp, "/", idxLvl, "/", idxVar)
        listQfqmNameTmp <- paste0("/",Para$Flow$Loc, "/", "dp01", "/", "qfqm", "/", idxDp, "/", idxLvl, "/", idxVar)

        #Read data from the input dp0p file
        listDataTmp <- base::lapply(listDataNameTmp, rhdf5::h5read, file = FileInp, read.attributes = TRUE)
        listQfqmTmp <- base::lapply(listQfqmNameTmp, rhdf5::h5read, file = FileInp, read.attributes = TRUE)

        #Apply group names to the list
        base::names(listDataTmp) <- idxVar
        base::names(listQfqmTmp) <- idxVar

        #base attributes
       
        # perform unit conversion
        listDataTmp[[idxVar]] <- base::suppressWarnings(eddy4R.base::def.unit.conv(data = listDataTmp[[idxVar]],
                                                                                   unitFrom = attributes(listDataTmp[[idxVar]])$unit,
                                                                                   unitTo = "intl",
                                                                                   MethGc = FALSE))
        #Add dp01 data into rpt
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$mean <- listDataTmp[[idxVar]]$mean
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$min <- listDataTmp[[idxVar]]$min
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$max <- listDataTmp[[idxVar]]$max
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$vari <- listDataTmp[[idxVar]]$vari
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$numSamp <- listDataTmp[[idxVar]]$numSamp
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$timeBgn <- base::as.POSIXct(listDataTmp[[idxVar]]$timeBgn, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$timeEnd <- base::as.POSIXct(listDataTmp[[idxVar]]$timeEnd, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        #unit attributes
        attributes(rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]])$unit <- attributes(listDataTmp[[idxVar]])$unit["mean"]

        #Add dp01 qfqm into rpt
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qmAlph <- listQfqmTmp[[idxVar]]$qmAlph
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qmBeta <- listQfqmTmp[[idxVar]]$qmBeta
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qfFinl <- listQfqmTmp[[idxVar]]$qfFinl
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qfSci <- listQfqmTmp[[idxVar]]$qfSci
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$timeBgn <- base::as.POSIXct(listQfqmTmp[[idxVar]]$timeBgn, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$timeEnd <- base::as.POSIXct(listQfqmTmp[[idxVar]]$timeEnd, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        #unit attributes
        attributes(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <- "NA"
      }
    }

  }; rm(idxVar)

  dp02 <- c("co2Stor", "h2oStor", "tempStor")

  #freq output for all data products
  #unit [min]
  resoTimeDp02 <- list(
    "co2Stor" = c(30) * 60, #output node in dp01
    "h2oStor" = c(30) * 60,  #output node in dp01
    "tempStor" = c(30) * 60  #output node in dp01


  )

  Para$Flow$dp02 <- list()

  Para$Flow$dp02$LvlTowrReso <- list(
    "co2Stor" = unique(sapply(1:length(unique(listPara$group[(grep("irgaStor/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("irgaStor/",listPara$group))]), "irgaStor/")[[xx]][2])),
    #"000_010" "000_020" "000_030" "000_040" "co2Arch" "co2High" "co2Low"  "co2Med"  "co2Zero", #sensor in dp0p
    "tempStor" = c(unique(sapply(1:length(unique(listPara$group[(grep("tempAirLvl/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirLvl/",listPara$group))]), "tempAirLvl/")[[xx]][2])), unique(sapply(1:length(unique(listPara$group[(grep("tempAirTop/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirTop/",listPara$group))]), "tempAirTop/")[[xx]][2])))
   
  )

  Para$Flow$dp02$LvlTowrReso$co2Stor <- paste0(Para$Flow$dp02$LvlTowrReso$co2Stor[which(substring(Para$Flow$dp02$LvlTowrReso$co2Stor, 1, 3) == "000")], "_02m")
  Para$Flow$dp02$LvlTowrReso$h2oStor <- Para$Flow$dp02$LvlTowrReso$co2Stor # output in dp01
  Para$Flow$dp02$LvlTowrReso$tempStor <- Para$Flow$dp02$LvlTowrReso$tempStor[which(substring(Para$Flow$dp02$LvlTowrReso$tempStor, 1, 3) == "000" & substring(Para$Flow$dp02$LvlTowrReso$tempStor, 9, 9) == "0")]


  Para$Flow$dp02$Var <- list()

  Para$Flow$dp02$Var <- list(
    "co2Stor" = "rtioMoleDryCo2", #output node in dp01
    "h2oStor" = "rtioMoleDryH2o",  #output node in dp01
    "tempStor" = "temp"  #output node in dp01


  )


  mapDp02Dp01 <- list(
    "co2Stor" = "co2Stor",
    "h2oStor" = "h2oStor",
    "tempStor" = c("tempAirLvl", "tempAirTop")
  )



  # for dp02 output
  wrk$dp02 <- list()


  #assign standard minutely time
  timeDp02 <- as.POSIXlt(seq.POSIXt(
    from = as.POSIXlt(paste(Date, " 00:00:00", sep=""), format="%Y-%m-%d %H:%M:%OS", tz="UTC"),
    to = as.POSIXlt(paste(Date, " 23:59:00", sep=""), format="%Y-%m-%d %H:%M:%OS", tz="UTC"),
    by = 60
  ), tz="UTC")


  #fractional UTC time [h UTC]
  timeFracDp02 <- timeDp02$hour + timeDp02$min / 60 + timeDp02$sec / 3600
  #clean up
  #rm(timeDp02)






  #workflow for L2 dp---------------------------------------------------------------
  #define idxLvl at the tower top of tempStor
  idxLvlTempStor <- paste0("000_0", Para$Flow$Site$LvlMeasTow, "0_01m", sep="")
  WndwMax <- 40*60 #[s]

  for(idxDp in dp02){
  
    idxVar <- Para$Flow$dp02$Var[[idxDp]]
    wrk$dp02[[idxDp]] <- list()

    #loop around different measurement levels as well as different aggregation time
    for(idxLvl in Para$Flow$dp02$LvlTowrReso[[idxDp]]){
     
      if(idxDp == "tempStor" & idxLvl == idxLvlTempStor) {
        tmpData <- rpt$dp01$data[[mapDp02Dp01[[idxDp]][2]]][[idxLvl]]
        tmpQfqm <- rpt$dp01$qfqm[[mapDp02Dp01[[idxDp]][2]]][[idxLvl]]
      } else {
        tmpData <- rpt$dp01$data[[mapDp02Dp01[[idxDp]][1]]][[idxLvl]]
        tmpQfqm <- rpt$dp01$qfqm[[mapDp02Dp01[[idxDp]][1]]][[idxLvl]]
      }





      #intepolation-----------------------------------------------------


      tmpItpl <- eddy4R.stor::def.itpl.time(
        dataInp = tmpData[[idxVar]],
        WndwMax = WndwMax, #maximum gap time [s]
        methItpl = "linear"
      )

      #intepolation for qfqm data----------------------------------------------------


      #assign actual time
      #convert to POSIXct, so the full date and time can be stored in as accessed as a single vector
      timeDp01 <- as.POSIXlt(tmpData[[idxVar]]$timeBgn, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")

      if(idxDp == "co2Stor" | idxDp == "h2oStor"){
        #timeBgn + numSamp/2/* 1/1Hz
        timeDp01 <- as.POSIXlt(timeDp01 + tmpData[[idxVar]]$numSamp/2*1/1, format="%Y-%m-%d %H:%M:%OS", tz="UTC")
      }

      #fractional UTC time [h UTC]
      tmpQfqm$timeFrac <- timeDp01$hour + timeDp01$min / 60 + timeDp01$sec / 3600
      #fractional day of year [DOY]
      tmpQfqm$DOYFrac <- timeDp01$yday + 1 +  tmpQfqm$timeFrac / 24
      #     #make sure that all entries are sorted ascending
      #       rpt$dp01$data$tmpOut <- rpt$dp01$data$tmpOut[order(rpt$dp01$data$tmpOut$UTC, decreasing=FALSE),]
      #clean up
      rm(timeDp01)


      #qfqm: determine which datapoints to assess
      setQfqmLgth <- length(which(!is.na(tmpQfqm[[idxVar]]$qfFinl)))

      #less than 2 values (minimum required by approx() function)
      if(setQfqmLgth < 2) {

        tmpQfqmItpl <- as.numeric(rep(1, length(timeDp02)))

        #interpolate actual data
      } else {

        tmpQfqmItpl <- zoo::na.approx(object=as.vector(tmpQfqm[[idxVar]]$qfFinl), x=#tmpData$timeFrac
                                        as.integer(tmpQfqm$timeFrac * 60)
                                      , xout=as.integer(timeFracDp02 * 60)
                                      , method = "linear", maxgap=WndwMax, na.rm=FALSE, rule=1, f=0)
        #replace qf that not = 0 to 1
        tmpQfqmItpl <- ifelse(tmpQfqmItpl != 0 | is.na(tmpQfqmItpl), 1, 0)
      }



  
      #---------calculate the change rate 4 minutely average at the end minus the begining 4 min average------------------------------------------------------------------------

      idxLvlReso <- paste0(substring(idxLvl, 1, 7), "_", as.integer(resoTimeDp02[[idxDp]] /60), "m")
      PrdWndwAgr <- 4 * 60 #unit [s]
      PrdIncrAgr <- as.integer(resoTimeDp02[[idxDp]])

      wrk$dp02[[idxDp]][[idxLvlReso]] <- eddy4R.stor::def.time.rate.diff(
        dataInp = tmpItpl,
        numDate = numDate,
        PrdWndwAgr = PrdWndwAgr,
        PrdIncrAgr = PrdIncrAgr,
        Date = substring(tmpData[[idxVar]]$timeBgn[1], 1, 10)
      )

      wrk$qfqmDp02[[idxDp]][[idxLvlReso]] <- eddy4R.stor::def.time.rate.diff(
        dataInp = tmpQfqmItpl,
        numDate = numDate,
        PrdWndwAgr = PrdWndwAgr,
        PrdIncrAgr = PrdIncrAgr,
        Date = substring(tmpData[[idxVar]]$timeBgn[1], 1, 10),
        qfqmFlag = TRUE

      )



    }; #rm(idxLvl)
    rlog$debug(idxDp)
  }; #rm(idxDp)




  # clean up

  invisible(gc())


  # end loop around aggregation interval
  rlog$info(paste0("dataset ", Date, " dp02 calculation complete!"))
  #save.image(wrk$dp02, file="~/wrkdp01_object.RData")
  save.image("~/wrkdp02.RData")




  # concatenate results and HDF5 data formatting-----------------------------------------------------------------------------------------
  #restructure output wrk$dp02:
  rpt$dp02$data <- eddy4R.base::def.hdf5.pack(inpList=wrk$dp02, MethMeas = "ecse", Dp ="Dp02")
  rpt$dp02$qfqm <- eddy4R.base::def.hdf5.pack(inpList=wrk$qfqmDp02, MethMeas = "ecse", Dp ="Dp02")

  #transfer units
  for(idxDp in base::names(rpt$dp02$data)) {
  
    for(idxLvl in base::names(rpt$dp02$data[[idxDp]])){
      for(idxVar in base::names(rpt$dp02$data[[idxDp]][[idxLvl]])){
       
        base::attr(x = rpt$dp02$data[[idxDp]][[idxLvl]][[idxVar]], which = "unit") <-
          paste0(base::attr(x = rpt$dp01$data[[mapDp02Dp01[[idxDp]][1]]][[1]][[Para$Flow$dp02$Var[[idxDp]]]], which = "unit"), " s-1")

      }
    }

  }

  #qfqm: transfer units
  for(idxDp in base::names(rpt$dp02$qfqm)) {
 
    for(idxLvl in base::names(rpt$dp02$qfqm[[idxDp]])){
      for(idxVar in base::names(rpt$dp02$qfqm[[idxDp]][[idxLvl]])){
      
        attributes(rpt$dp02$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <-
          attributes(rpt$dp01$qfqm[[mapDp02Dp01[[idxDp]][1]]][[1]][[Para$Flow$dp02$Var[[idxDp]]]])$unit

      }
    }

  }
  
  
```


## 6. ECSE level 3 data products (dp03) generation.

First vertically interpolate ECSE dp02 to get vertically resolved time change of rate, using eddy4R.stor::def.itpl.spce();
Then also intepolate ECSE Level 2 qfqm data; 
Then concatenate results and HDF5 data formatting.



```{r dp03-process,  message=F, warning=F}

#dp03 ecse generation-------------------------------------------------------------------------------------------------------------
rlog$debug(paste0("dataset ", Date, " dp03 calculation begins!"))

dp03 <- c("co2Stor", "h2oStor", "tempStor")

#vertical resolution is 0.1 m
resoSpceOut <- 0.1

lvlTowr <- Para$Flow$Site$DistZaxsLvlMeasTow

#vertical resolution is 0.1 m
spceStad <- c(1:(max(as.numeric(lvlTowr))/resoSpceOut)) * resoSpceOut

spce <- as.numeric(lvlTowr)


wrk$dp03 <- list()

#data calculation processing
for(idxDp in dp03){
  idxVar <- names(rpt$dp02$data[[idxDp]][[1]])


  #interpolate vertically
  wrk$dp03[[idxDp]][[idxVar]] <- list()

  for(idxAgr in 1:length(rpt$dp02$data[[idxDp]][[1]][[1]][[1]])){
  
    #get dp02 data from each measurement level
    tmpData <- sapply(1:length(Para$Flow$dp02$LvlTowrReso[[idxDp]]), function(x) rpt$dp02$data[[idxDp]][[x]][[1]]$mean[idxAgr])


    tmpDp03 <- eddy4R.stor::def.itpl.spce(
      dataInp = tmpData,
      methItpl = "linear",
      resoSpceOut = resoSpceOut,
      lvlTowr = lvlTowr

    )


    if(idxAgr == 1) {
      wrk$dp03[[idxDp]][[idxVar]] <- tmpDp03
    } else {
      wrk$dp03[[idxDp]][[idxVar]] <- rbind(wrk$dp03[[idxDp]][[idxVar]], tmpDp03)
    }


  }# end of loop around idxAgr



  wrk$dp03[[idxDp]][[idxVar]] <- data.frame(wrk$dp03[[idxDp]][[idxVar]])
  #dimnames(wrk$dp03[[idxDp]][[idxVar]])[[1]] <- rpt$dp02$data[[idxDp]][[1]][[1]]$timeBgn
  dimnames(wrk$dp03[[idxDp]][[idxVar]])[[2]] <- as.character(paste0(spceStad, " m"))


  #wrk$dp03[[idxDp]][[idxVar]] <- cbind(rpt$dp02$data[[idxDp]][[1]][[1]]$timeBgn, wrk$dp03[[idxDp]][[idxVar]])
  wrk$dp03[[idxDp]][[idxVar]]$timeBgn <- rpt$dp02$data[[idxDp]][[1]][[1]]$timeBgn
  wrk$dp03[[idxDp]][[idxVar]]$timeEnd <- rpt$dp02$data[[idxDp]][[1]][[1]]$timeEnd


} # end of loop around idxDp

wrk$qfqmDp03 <- list()
#qfqm calculation processing
for(idxDp in dp03){
  idxVar <- names(rpt$dp02$qfqm[[idxDp]][[1]])


  #interpolate vertically
  wrk$qfqmDp03[[idxDp]][[idxVar]] <- list()

  for(idxAgr in 1:length(rpt$dp02$qfqm[[idxDp]][[1]][[1]][[1]])){
  
    #get dp02 data from each measurement level
    tmpQfqm <- sapply(1:length(Para$Flow$dp02$LvlTowrReso[[idxDp]]), function(x) rpt$dp02$qfqm[[idxDp]][[x]][[1]]$qfFinl[idxAgr])
    #interpolate vertically
    tmpQfqmDp03 <- zoo::na.approx(object=as.vector(tmpQfqm), x=#tmpData$timeFrac
                                    spce
                                  , xout=spceStad
                                  , method = "linear",
                                  na.rm=TRUE#,#if you want begining and end to be constant fitted, na.rm=TRUE
                                  #rule=1, f=0
    )
    #fill in the data before 1st measurement level with 1st interpolation data
    tmpQfqmDp03 <- c(rep(tmpQfqmDp03[1], length(spceStad) - length(tmpQfqmDp03)), tmpQfqmDp03)
    #replace qf that not = 0 to 1
    tmpQfqmDp03 <- as.integer(ifelse(tmpQfqmDp03 != 0 | is.na(tmpQfqmDp03), 1, 0))

    #gethering all data
    if(idxAgr == 1) {
      wrk$qfqmDp03[[idxDp]][[idxVar]] <- tmpQfqmDp03
    } else {
      wrk$qfqmDp03[[idxDp]][[idxVar]] <- rbind(wrk$qfqmDp03[[idxDp]][[idxVar]], tmpQfqmDp03)
    }

  }# end of loop around idxAgr



  wrk$qfqmDp03[[idxDp]][[idxVar]] <- data.frame(wrk$qfqmDp03[[idxDp]][[idxVar]])
  #dimnames(wrk$dp03[[idxDp]][[idxVar]])[[1]] <- rpt$dp02$data[[idxDp]][[1]][[1]]$timeBgn
  dimnames(wrk$qfqmDp03[[idxDp]][[idxVar]])[[2]] <- as.character(paste0(spceStad, " m"))


  #wrk$dp03[[idxDp]][[idxVar]] <- cbind(rpt$dp02$data[[idxDp]][[1]][[1]]$timeBgn, wrk$dp03[[idxDp]][[idxVar]])
  wrk$qfqmDp03[[idxDp]][[idxVar]]$timeBgn <- rpt$dp02$qfqm[[idxDp]][[1]][[1]]$timeBgn
  wrk$qfqmDp03[[idxDp]][[idxVar]]$timeEnd <- rpt$dp02$qfqm[[idxDp]][[1]][[1]]$timeEnd


} # end of loop around idxDp
rpt$dp03$data <- wrk$dp03
rpt$dp03$qfqm <- wrk$qfqmDp03

#data: transfer units
for(idxDp in base::names(rpt$dp03$data)) {
 
   for(idxVar in base::names(rpt$dp03$data[[idxDp]])){
  
    base::attr(x = rpt$dp03$data[[idxDp]][[idxVar]], which = "unit") <-
      base::attr(x = rpt$dp02$data[[idxDp]][[1]][[idxVar]], which = "unit")

  }

}

#qfqm: transfer units
for(idxDp in base::names(rpt$dp03$qfqm)) {
 
  for(idxVar in base::names(rpt$dp03$qfqm[[idxDp]])){
 
    attributes(rpt$dp03$qfqm[[idxDp]][[idxVar]])$unit <-
      attributes(rpt$dp02$qfqm[[idxDp]][[1]][[idxVar]])$unit
  }

}
rm(tmpData, tmpQfqm)

rlog$info(paste0("dataset ", Date, " dp03 calculation complete!"))

  
```



## 7. ECSE level 4 data products (dp04) generation.

First spatial intergrate ECSE dp03 to get storage flux, using eddy4R.stor::def.flux.stor();
Then also calculate ECSE Level 3 qfqm to get dp04 qfqm; 
Then concatenate results and HDF5 data formatting.



```{r dp04-process,  message=F, warning=F}

  rlog$debug(paste0("dataset ", Date, " dp04 calculation begin!"))

  wrk$dp04 <- list()

  for(idxDp in names(rpt$dp03$data)){
    idxVar <- names(rpt$dp03$data[[idxDp]])


    tmpData <- rpt$dp03$data[[idxDp]][[idxVar]]


    tmpDp04 <- eddy4R.stor::def.flux.stor(
      dataInp = tmpData,
      lvlTowr = LvlTowr
    )

    wrk$dp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$mean <- tmpDp04$mean
    wrk$dp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeBgn <- tmpDp04$timeBgn
    wrk$dp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeEnd <- tmpDp04$timeEnd

  }

  #dp04 qfqm claculation
  wrk$qfqmDp04 <- list()

  for(idxDp in names(rpt$dp03$qfqm)){
    idxVar <- names(rpt$dp03$qfqm[[idxDp]])


    tmpQfqm <- rpt$dp03$qfqm[[idxDp]][[idxVar]]
    tmpQfqm$timeBgn <- NULL
    tmpQfqm$timeEnd <- NULL
    #tmpData <- as.matrix(tmpData)


    #mean of dp03*(tower height - displacement height)
    wrk$qfqmDp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$qfFinl <- as.integer(apply(tmpQfqm, 1, function(x) ifelse(any(x==1),1,0)))
    wrk$qfqmDp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeBgn <- rpt$dp03$qfqm[[idxDp]][[idxVar]]$timeBgn
    wrk$qfqmDp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeEnd <- rpt$dp03$qfqm[[idxDp]][[idxVar]]$timeEnd

  }
  rpt$dp04$data <- wrk$dp04
  rpt$dp04$qfqm <- wrk$qfqmDp04

  #transfer units
  for(idxDp in base::names(rpt$dp04$data)) {
  
      for(idxVar in base::names(rpt$dp04$data[[idxDp]])){
     

      tmpUnit <- base::attr(x = rpt$dp03$data[[idxDp]][[paste0("rate", substring(idxVar, 9, nchar(idxVar)))]], which = "unit")
      base::attr(x = rpt$dp04$data[[idxDp]][[idxVar]], which = "unit") <- paste0(substring(tmpUnit, 1, (nchar(tmpUnit) - 3)), "m ", substring(tmpUnit, (nchar(tmpUnit) - 2)))

    }

  }

  #qfqm: transfer units
  for(idxDp in base::names(rpt$dp04$qfqm)) {
  
    for(idxVar in base::names(rpt$dp04$qfqm[[idxDp]])){
     
      attributes(rpt$dp04$qfqm[[idxDp]][[idxVar]])$unit <-
        attributes(rpt$dp03$qfqm[[idxDp]][[paste0("rate", substring(idxVar, 9, nchar(idxVar)))]])$unit
    }

  }
  rm(tmpData, tmpQfqm)

  #assign new name for dp04 and sub dp04
  names(rpt$dp04$data$co2Stor) <- c("stor")
  names(rpt$dp04$data$h2oStor) <- c("stor")
  names(rpt$dp04$data$tempStor) <- c("stor")
  names(rpt$dp04$data) <- c("fluxCo2", "fluxH2o", "fluxTemp")

  #assign new name for dp04 and sub dp04
  names(rpt$dp04$qfqm$co2Stor) <- c("stor")
  names(rpt$dp04$qfqm$h2oStor) <- c("stor")
  names(rpt$dp04$qfqm$tempStor) <- c("stor")
  names(rpt$dp04$qfqm) <- c("fluxCo2", "fluxH2o", "fluxTemp")

  rlog$info(paste0("dataset ", Date, " dp04 calculation complete!"))

  #performing unit conversion
  #data
  rpt <- eddy4R.base::wrap.unit.conv.out.ec(inpList = rpt, MethMeas = "ecse", MethType = "Data")
  #qfqm
  rpt <- eddy4R.base::wrap.unit.conv.out.ec(inpList = rpt, MethMeas = "ecse", MethType = "Qfqm")
  #ucrt
  rpt <- eddy4R.base::wrap.unit.conv.out.ec(inpList = rpt, MethMeas = "ecse", MethType = "Ucrt")

```


## 8. HDF5 write out

First transfer units and metadata to ECSE dp01-dp04
Then HDF5 data formatting and output.



```{r hdf5-output,  message=F, warning=F}

 #Create structure for hdf5------------------------------------------------------------------------------------------------------


  rlog$debug(paste0("dataset ", Date, ": HDF5 generation"))
  #LvlTowr <- "_"
  DirHdf5Out <- Para$Flow$DirOut
  #LvlDp <- "dp04"

  #fomatting Date for file names
  dateFileInp <- gsub(pattern = "-", replacement = "", x = Date)

  #Check to see if the directory exists, if not create the directory. Recursive required to write nested file directories
  if (dir.exists(DirHdf5Out) == FALSE) dir.create(DirHdf5Out, recursive = TRUE)

  #write out metadata at different hdf5 levels--------------------------------------------------------------------------------------
  #Writing metadata from input dp0p file to output dp01 file for both basic and expand package
  for (idxPack in c("expanded", "basic")){
    #Create the file, create a class
    #Create the file, create a class
    idFile <- rhdf5::H5Fcreate(paste0(DirHdf5Out,"/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"))
    #If the file is already created use:
    #idFile <- H5Fopen("HDF5TIS_L0_prototype.h5")
    # idFile <- rhdf5::H5Fopen(paste0(DirHdf5Out,"/","ECSE_",LvlDp,"_", Para$Flow$Loc, "_", Date, "_new_format.h5"))

    #Create a group level for SERC
    idSite <- rhdf5::H5Gcreate(idFile, Para$Flow$Loc)



    lapply(c("dp02"), function(n1)
      #n1 <- "dp01"

    {
      idn1 <- rhdf5::H5Gcreate(idSite, n1)

      lapply(names(rpt[[n1]]), function(n2)
        #n2 <- names(rpt[[n1]])[1]

      {idn2 <- rhdf5::H5Gcreate(idn1, n2)

      lapply(names(rpt[[n1]][[n2]]), function(n3) {
        idn3 <- rhdf5::H5Gcreate(idn2, n3)
        lapply(names(rpt[[n1]][[n2]][[n3]]), function(n4) {
          rhdf5::H5Gcreate(idn3, n4)
        }) } ) }) })#end of lapply




    lapply(c("dp03", "dp04"), function(n1)
      #n1 <- "dp03"

    {
      idn1 <- rhdf5::H5Gcreate(idSite, n1)

      lapply(names(rpt[[n1]]), function(n2)
        #n2 <- names(rpt[[n1]])[1]

      {idn2 <- rhdf5::H5Gcreate(idn1, n2)

      lapply(names(rpt[[n1]][[n2]]), function(n3) {
        idn3 <- rhdf5::H5Gcreate(idn2, n3)

      })})} )#end of lapply

    rhdf5::H5Gclose(idSite)
    rhdf5::H5Fclose(idFile)
    rhdf5::h5closeAll()

    eddy4R.base::def.hdf5.extr(FileInp = Para$Flow$DirFilePara,
                               FileOut = paste0(Para$Flow$DirOut, "/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"),
                               dp01 = c("co2Stor", "h2oStor", "isoCo2", "isoH2o"))
    #Open the output file HDF5 link
    idFile <- rhdf5::H5Fopen(paste0(Para$Flow$DirOut, "/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"))

    #Write the attributes to the new file
    listAttr <- list()
    listAttr[[paste0("//", Para$Flow$Loc)]] <- Para$Flow$Site
    for(idxDp in c("co2Stor", "h2oStor", "isoCo2", "isoH2o", "tempAirLvl", "tempAirTop")){
      
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      #qfqm
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]])
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      #ucrt
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )

      if(idxDp %in% c("co2Stor", "h2oStor", "isoCo2")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", as.integer(resoTimeDp01[[idxDp]][2] ))
      if(idxDp %in% c("isoH2o")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", "NA", as.integer(resoTimeDp01[[idxDp]][3]))
      #qfqm
      if(idxDp %in% c("co2Stor", "h2oStor", "isoCo2")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", as.integer(resoTimeDp01[[idxDp]][2]))
      if(idxDp %in% c("isoH2o")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", "NA", as.integer(resoTimeDp01[[idxDp]][3]))
      #ucrt
      if(idxDp %in% c("co2Stor", "h2oStor", "isoCo2")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", as.integer(resoTimeDp01[[idxDp]][2]))
      if(idxDp %in% c("isoH2o")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", "NA", as.integer(resoTimeDp01[[idxDp]][3]))
    }

    for(idxDp in c("co2Stor", "h2oStor", "tempStor")){
     
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/data/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/qfqm/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]])
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]])

      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]][["SpceWndwAgrDflt"]] <- resoSpceOut
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]][["SpceWndwAgrDflt"]] <- resoSpceOut
    }

    resoTimeDp04 <- list(
      "fluxCo2" = c(30) * 60, #output node in dp04
      "fluxH2o" = c(30) * 60,  #output node in dp04
      "fluxTemp" = c(30) *60  #output node in dp04
    )

    for(idxDp in c("fluxCo2", "fluxH2o", "fluxTemp")){
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/data/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/qfqm/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )

    }




    #x <- "/CPER/dp0p/data/irgaStor_001/000_020"
    idData <- rhdf5::H5Oopen(idFile, paste0("//", Para$Flow$Loc))

    # base::lapply(names(Para$Flow$Site), function(y){
    #   #y <- names(listAttr[[x]])[1]
    #   rhdf5::h5writeAttribute(attr = Para$Flow$Site[[y]], h5obj = idData, name = y)
    #   }
    #   )


    #Write the attributes to the new file
    lapply(names(listAttr), function(x){

      #x <- names(listAttr)[12]   #"//CPER"
      idData <- rhdf5::H5Oopen(idFile, x)
      base::lapply(names(listAttr[[x]]), function(y){
        #y <- names(listAttr[[x]])[1]
        #Check for logicals and convert to numeric
        if(is.logical(listAttr[[x]][[y]])) listAttr[[x]][[y]] <<- as.numeric(listAttr[[x]][[y]])

        rhdf5::h5writeAttribute(attr = listAttr[[x]][[y]], h5obj = idData, name = y)
      }
      )
    })

    # empty dp01 for dp which already exits in input dp0p HDF5
    for (idxDp01 in c("tempAirLvl", "tempAirTop")){
      rpt$dp01$data[[idxDp01]] <- NULL
      rpt$dp01$qfqm[[idxDp01]] <- NULL
    }
    #Write output to hdf5 file----------------------------------------------------------------------------------------

    idFile <- rhdf5::H5Fopen(paste0(Para$Flow$DirOut, "/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"))

    #Write output to hdf5 file for data dp01 and dp02
    lapply(c("dp01", "dp02"), function(idxLvlDp) {
      #idxLvlDp <- names(rpt)[1]
      lapply(names(rpt[[idxLvlDp]]$data), function(idxDp) {
        #idxDp <- names(rpt[[idxLvlDp]]$data)[1]
        lapply(names(rpt[[idxLvlDp]]$data[[idxDp]]), function(idxLvLReso) {
          #idxLvLReso <- names(rpt[[idxLvlDp]]$data[[idxDp]])[1]


          nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/data/",idxDp,"/",idxLvLReso))
          lapply(names(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]]), function(idxVar){

            #idxVar <- names(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]])[1]
            rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
            if (!is.null(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]][[idxVar]])$unit) == TRUE){
              dgid <- rhdf5::H5Dopen(nid, idxVar)
              rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]][[idxVar]])$unit, h5obj = dgid, name = "unit")
              #rhdf5::h5writeDataset.data.frame(obj = aa$temp, h5loc = nid, name = idxLvLReso)
            }})} ) }) })

    #only output qfFinl in the basic package
    if (idxPack %in% "basic"){
      for(idxDp in base::names(rpt$dp01$qfqm)) {
      
        for(idxLvl in base::names(rpt$dp01$qfqm[[idxDp]])){
           for(idxVar in base::names(rpt$dp01$qfqm[[idxDp]][[idxLvl]])){
            #output only qfFinl

            rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]] <- rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]][which((names(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]) %in% c("qfFinl",  "timeBgn", "timeEnd")))]
            #unit transfer
            attributes(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <-
              attributes(wrk$qfqmOut[[idxDp]][[idxLvl]][[1]]$qfFinl[[idxVar]])$unit

          }
        }

      }; rm(idxVar)

    }# close if statment of idxPack = "basic

    #Write output to hdf5 file for qfqm dp01 and dp02
    lapply(c("dp01", "dp02"), function(idxLvlDp) {
      #idxLvlDp <- names(rpt)[1]
      lapply(names(rpt[[idxLvlDp]]$qfqm), function(idxDp) {
        #idxDp <- names(rpt[[idxLvlDp]]$data)[1]
        lapply(names(rpt[[idxLvlDp]]$qfqm[[idxDp]]), function(idxLvLReso) {
          #idxLvLReso <- names(rpt[[idxLvlDp]]$data[[idxDp]])[1]


          nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/qfqm/",idxDp,"/",idxLvLReso))
          lapply(names(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]]), function(idxVar){

            #idxVar <- names(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]])[1]
            rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
            if (!is.null(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]][[idxVar]])$unit) == TRUE){
              dgid <- rhdf5::H5Dopen(nid, idxVar)
              rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]][[idxVar]])$unit, h5obj = dgid, name = "unit")
              #rhdf5::h5writeDataset.data.frame(obj = aa$temp, h5loc = nid, name = idxLvLReso)
            } })} )})})

    #Write output to hdf5 file for ucrt dp01
    lapply(c("dp01"), function(idxLvlDp) {
      #idxLvlDp <- names(rpt)[1]
      lapply(names(rpt[[idxLvlDp]]$ucrt), function(idxDp) {
        #idxDp <- names(rpt[[idxLvlDp]]$ucrt)[1]
        lapply(names(rpt[[idxLvlDp]]$ucrt[[idxDp]]), function(idxLvLReso) {
          #idxLvLReso <- names(rpt[[idxLvlDp]]$data[[idxDp]])[1]


          nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/ucrt/",idxDp,"/",idxLvLReso))
          lapply(names(rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]]), function(idxVar){

            #idxVar <- names(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]])[1]
            rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
            if (!is.null(attributes(rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]][[idxVar]])$unit) == TRUE){
              dgid <- rhdf5::H5Dopen(nid, idxVar)
              rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]][[idxVar]])$unit, h5obj = dgid, name = "unit")
              #rhdf5::h5writeDataset.data.frame(obj = aa$temp, h5loc = nid, name = idxLvLReso)
            }})})})})

    #Write output to hdf5 file for data dp03 and dp04
    lapply(c("dp03", "dp04"), function(idxLvlDp) {
      #idxLvlDp <- names(rpt)[1]
      lapply(names(rpt[[idxLvlDp]]$data), function(idxDp) {
        #idxDp <- names(rpt[[idxLvlDp]]$data)[1]

        nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/data/",idxDp))
        lapply(names(rpt[[idxLvlDp]]$data[[idxDp]]), function(idxVar) {
          #idxLvLReso <- names(rpt[[idxLvlDp]]$data[[idxDp]])[1]


          #idxVar <- names(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]])[1]
          rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$data[[idxDp]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
          #rhdf5::h5writeDataset.data.frame(obj = aa$temp, h5loc = nid, name = idxLvLReso)
          if (!is.null(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxVar]])$unit) == TRUE){
            dgid <- rhdf5::H5Dopen(nid, idxVar)
            rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxVar]])$unit, h5obj = dgid, name = "unit")
            #rhdf5::h5writeDataset.data.frame(obj = aa$temp, h5loc = nid, name = idxLvLReso)
          }})})})

    #Write output to hdf5 file for qfqm dp03 and dp04
    lapply(c("dp03", "dp04"), function(idxLvlDp) {
      #idxLvlDp <- names(rpt)[1]
      lapply(names(rpt[[idxLvlDp]]$qfqm), function(idxDp) {
        #idxDp <- names(rpt[[idxLvlDp]]$qfqm)[1]

        nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/qfqm/",idxDp))
        lapply(names(rpt[[idxLvlDp]]$qfqm[[idxDp]]), function(idxVar) {
          #idxLvLReso <- names(rpt[[idxLvlDp]]$qfqm[[idxDp]])[1]


          #idxVar <- names(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]])[1]
          rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
          #rhdf5::h5writeDataset.data.frame(obj = aa$temp, h5loc = nid, name = idxLvLReso)
          if (!is.null(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxVar]])$unit) == TRUE){
            dgid <- rhdf5::H5Dopen(nid, idxVar)
            rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxVar]])$unit, h5obj = dgid, name = "unit")
            #rhdf5::h5writeDataset.data.frame(obj = aa$temp, h5loc = nid, name = idxLvLReso)
          }})})})

    # #unit of
    # lapply(names(dataList2), function(x) {
    #   if (!is.null(attributes(dataList2[[x]])$unit) == TRUE){
    #     dgid <- rhdf5::H5Dopen(gid30, x)
    #     rhdf5::h5writeAttribute(attributes(dataList2[[x]])$unit, h5obj = dgid, name = "unit")
    #   }})
    rhdf5::h5closeAll()
  }#closed loop for idxPack

  rlog$info(paste0("dataset ", Date, ": HDF5 generation complete!"))


  # create directory
  dir.create(paste0(Para$Flow$DirOut, "/", Para$Flow$Loc, "/", Para$Flow$VersDp), showWarnings = FALSE, recursive = TRUE)
  #write to csv file for flow.test.gold.eddy.R testing--------------------------------------------------

  #idxDpLvl <- "dp01"
  for(idxDpLvl in names(rpt)){
 
    for(idxDp in names(rpt[[idxDpLvl]]$data)){
    

   
      #for(idxVari in names(rpt[[idxDpLvl]]$data[[idxDp]])){
      idxVari <- names(rpt[[idxDpLvl]]$data[[idxDp]])[1]

      #write to file
      utils::write.csv(rpt[[idxDpLvl]]$data[[idxDp]][[idxVari]], file = paste0(Para$Flow$DirOut, "/", Para$Flow$Loc, "/", Para$Flow$VersDp, "/", idxDpLvl, "-", idxDp, "-",  idxVari, ".csv"), col.names = FALSE,
                       na = "NaN", row.names = FALSE, quote=FALSE)

    }
  }

```
