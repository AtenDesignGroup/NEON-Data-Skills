---
title: "Example workflow for processing NEON eddy-covariance storage data with eddy4R-Docker 1.0.0"
author: "Ke Xu, Natchaya Pingintha-Durden, David Durden, Stefan Metzger"
date: "11/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## 0. Install and set up

This vignette assumes you are working with eddy4R within the Docker 
environment established by NEON. To get set up in that environment, 
follow the instructions <a href="neonscience.org/set-up-docker" target="_blank">here</a>.

At the end of those instructions, you should have an RStudio 
environment running within Docker. Use that workspace for this 
vignette.

## 1. Install packages and set up environment

First, check for required packages and install any that aren't 
already installed. Once all required packages are installed, 
load them into the environment.

Throughout this vignette, we use the `package::function()` 
syntax to explicitly refer to functions. This is done to avoid any 
possibility of ambiguity, in case there are functions in 
different packages with the same name.


```{r pack-install}

# Load and attach required  packages
packReq <- c("Hmisc")

lapply(packReq, function(x) {
  print(x)
  if(require(x, character.only = TRUE) == FALSE) {
    utls::install.packages(x)
    library(x, character.only = TRUE)
  }})
# Remove workflow package list
rm(packReq)

# Load and attach packages
library(DataCombine)
library(eddy4R.base)
library(eddy4R.turb)
library(eddy4R.stor)
library(methods)
library(rhdf5)
library(Hmisc)

```


## 2. Set environment variables, read in metadata, and ingest the additional dp01 data from NEON portal

Here we set file paths and basic input parameters as environment 
variables for convenience.


```{r env-vars}

# Define global environment
eddy4R.base::def.env.glob()

# File path for the directory containing input L0' data 
if(FALSE) {
  # set to FALSE if not under developement
  base::Sys.setenv("DEVE" = "FALSE")
  base::Sys.setenv("DIRINP" = paste0("/home/", Sys.getenv("USER"), "/eddy/data/irga/inpRefe/KONZ/ECSE"))
  base::Sys.setenv("DIRMNT" = paste0("/home/", Sys.getenv("USER"), "/eddy"))
  base::Sys.setenv("DIROUT" = paste0("/home/", Sys.getenv("USER"), "/eddy/data/irga/outRefe/KONZ"))
  base::Sys.setenv("FILEOUTBASE" = "ECSE_dp04_KONZ")
  base::Sys.setenv("DATEOUT" = "2018-11-28")
  base::Sys.setenv("METHPARAFLOW" = "EnvVar")
  base::Sys.setenv("VERSDP" = "001")
}

# Create an empty list for parameters.
Para <- base::list()

# Check environment variables for eddy4R workflow parameter "DirFilePara"
if("METHPARAFLOW" %in% base::names(base::Sys.getenv())) {

  Para$Flow <- eddy4R.base::def.para.flow(MethParaFlow = "EnvVar")

  # in case no dp0p h5 file is specified for parameters, download gold files and assign corresponding DirFilePara
} else {

  #The dates for the run must be specified, this set is for the gold file
  DateOut<- "2018-11-28" 
  FileOutBase <- "ECSE_dp04_KONZ"
  Para$Flow <- eddy4R.base::def.para.flow(DateOut = DateOut, FileOutBase = FileOutBase, MethParaFlow = "DfltInp",
    UrlInpRefe = "https://s3.data.neonscience.org/neon-ec-goldfiles/EC-storage-processing/inpRefeStor_20190708.zip",
    UrlOutRefe = "https://s3.data.neonscience.org/neon-ec-goldfiles/EC-storage-processing/outRefeStor_20190708.zip")
}


# Read in parameters from the HDF5 file.
# Grab the NEON specific 4-letter code for the site location (Loc)
Para$Flow$Loc <- eddy4R.base::def.para.site(FileInp = Para$Flow$DirFilePara)$Loc

# Grab the tower top level
Para$Flow$LvlTowrTop <- eddy4R.base::def.para.site(FileInp = Para$Flow$DirFilePara)$LvlTowr
Para$Flow$LvlTowrTop <- Para$Flow$LvlTowrTop[length(Para$Flow$LvlTowrTop)]

# Use the definition function to grab temperature data from NEON portal
# Indicating which data will be grab
DpName <- c("tempAirLvl", "tempAirTop")

# List all group hdf5 path before adding the existing data
listParaPre <- rhdf5::h5ls(Para$Flow$DirFilePara, datasetinfo = FALSE)

# Get the measurement location for each reingest data (DpName) from the input file
Para$Flow$dp01Exis$Lvl <- list()
for (i in 1:length(DpName)){
  nameSens <- paste0("/", Para$Flow$Loc, "/dp01/data/", DpName[i])
  tmpLvl <- listParaPre$name[which(listParaPre$group %in% nameSens)]
  # Get rid of averaging period
  tmpLvl <- grep(pattern = "30m", x = tmpLvl, ignore.case = TRUE, value =  TRUE)
  tmpLoc <- strsplit(as.character(tmpLvl),split='_', fixed=TRUE)
  Para$Flow$dp01Exis$Lvl[[DpName[i]]] <- unlist(lapply(1:length(tmpLoc), function(x) {as.character(paste0(tmpLoc[[x]][1], "_", tmpLoc[[x]][2]))}))
}

# Begin to re-ingest the existing dp01 data
base::invisible(eddy4R.base::wrap.hdf5.wrte.dp01.api(date = Para$Flow$DateOut, SiteLoca = Para$Flow$Loc, FileOut = Para$Flow$DirFilePara, LvlTowr = Para$Flow$dp01Exis$Lvl, DpName = DpName))

# Setting workflow parameters
# Working directory
if(is.na(Para$Flow$DirWrk)) {
  # default: use temporary working directory on Docker filesystem
  Para$Flow$DirWrk <- tempdir()

  # option: create user-specified working directory, e.g. on host filesystem
} else {

  dir.create(Para$Flow$DirWrk, recursive = TRUE, showWarnings = FALSE)

}

# Set working directory
setwd(Para$Flow$DirWrk)

# Input directory
if(is.na(Para$Flow$DirInp)) {
  # default: use temporary working directory on Docker filesystem
  Para$Flow$DirInp <- paste0(Para$Flow$DirWrk, "/inpRefe")

  # option: create user-specified input directory (if not existing), e.g. on host filesystem
} else {

  dir.create(Para$Flow$DirInp, recursive = TRUE, showWarnings = FALSE)

}

# Output directory
if(is.na(Para$Flow$DirOut)) {
  # default: use temporary working directory on Docker filesystem
  Para$Flow$DirOut <- paste0(Para$Flow$DirWrk, "/out")

  # option: create user-specified input directory (if not existing), e.g. on host filesystem
} else {

  dir.create(Para$Flow$DirOut, recursive = TRUE, showWarnings = FALSE)

}

# Get site information
Para$Flow$Site <- eddy4R.base::def.hdf5.read.para(
  DirFileParaLoca = Para$Flow$DirFilePara,
  GrpName = paste0("/", Para$Flow$Loc)
)

# Assign de-spiking parameters:
#   widt: WndwDspkBr86 de-spiking median filter window width [s]
#   nbin: NumDspkBr86Bin de-spiking histogram bins initial number/step size
#   rest: ThshDspkBr86Reso de-spiking resolution threshold
DespLoca <- list(widt = 9,
                 nbin = 2,
                 rest = 10)

# List of sensors and variables for which to perform de-spiking
DespLoca$var <- list()

DespLoca$var$irgaStor <- c("asrpCo2", "asrpH2o", "pres", "rtioMoleDryCo2", "rtioMoleDryH2o", "rtioMoleWetCo2", "rtioMoleWetH2o", "temp")
DespLoca$var$mfcSampStor <- c("frt", "frt00", "frtSet00", "presAtm", "temp")
DespLoca$var$mfcValiStor <- DespLoca$var$mfcSampStor
DespLoca$var$crdCo2 <- c("dlta13CCo2", "pres", "rtioMoleDry12CCo2", "rtioMoleDry13CCo2", "rtioMoleDryCo2",    "rtioMoleDryH2o", "rtioMoleWet12CCo2", "rtioMoleWet13CCo2", "rtioMoleWetCo2", "rtioMoleWetH2o", "temp",           "tempWbox")
DespLoca$var$crdH2o <- c("rtioMoleWetH2o", "rtioMoleDryH2o", "dlta18OH2o", "dlta2HH2o", "temp", "pres")
DespLoca$var$crdH2oValvVali <- "injNum"
DespLoca$var$envHut <- c("rtioMoleWetH2o", "rh", "temp", "pres")
DespLoca$var$mfm <- c("frt", "frt00", "presAtm", "temp")
DespLoca$var$presInlt <-c("presDiff")
DespLoca$var$presValiRegInStor <- c("presDiff")
DespLoca$var$presValiRegOutStor <- c("presDiff")

# Create a list of output frequencies for all data products
# unit [min]
resoTimeDp01 <- list(
  "co2Stor" = c(2, 30) * 60, 
  "h2oStor" = c(2, 30) * 60,  
  "tempAirLvl" = c(1,  30) * 60,  
  "tempAirTop" = c(1, 30) * 60,  
  "isoCo2" = c(9, 30) * 60,  
  "isoH2o" = c(3, 9, 30) * 60, 
  "irgaStor" = c(2, 30) * 60, 
  "mfcSampStor" = c(2, 30) * 60, 
  "mfcValiStor" = c(2, 30) * 60, 
  "mfm" = c(2, 30) * 60 
)

# Mapping dp01 name and sensor name
MapSensDp01 <- list(
  "co2Stor" = "irgaStor",
  "h2oStor" = "irgaStor"
)

# List all group hdf5 path
listPara <- rhdf5::h5ls(Para$Flow$DirFilePara, datasetinfo = FALSE)

# Creat list of input sensor 
Sens <- c("irgaStor", "mfcSampStor", "mfcValiStor", "irgaValvLvl", "crdCo2", 
             "crdH2o", "crdH2oValvVali", "crdCo2ValvLvl", "crdH2oValvLvl", "envHut", 
             "valvAux", "mfm", "presInlt", "presValiRegInStor", "presValiRegOutStor", "pumpStor", "rhSens")

# Get parameter of sensor sampling frequencies
Para$Flow$dp0p <- list()
for(idxSens in Sens){
  Para$Flow$dp0p[[idxSens]] <- list()
  Para$Flow$dp0p[[idxSens]]$FreqSamp <- eddy4R.base::def.hdf5.read.para(
    DirFileParaLoca = Para$Flow$DirFilePara,
    GrpName = paste0("/", Para$Flow$Loc, "/dp0p/data/", idxSens)
  )$FreqSamp
  
  # Note that the input frequency is the sensor sampling frequency, including the parameter of frequency such as ~1 and varies in crdCo2 and crdH2o, and 0.2 in valvAux, but the actual input dp0p data frequency is already adjusted to 1 Hz in dp0p, therefore, here we adjust freqSamp to 1
  Para$Flow$dp0p[[idxSens]]$FreqSamp <- 1
}


# Get the measurement location for each sensor from the input file
Para$Flow$dp01$LvlTowr <- list()
for (i in 1:length(Sens)){
  nameSens <- paste0(Sens[i], "/")
  Para$Flow$dp01$LvlTowr[[Sens[i]]] = unique(sapply(1:length(unique(listPara$group[(grep(nameSens,listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep(nameSens,listPara$group))]), nameSens)[[xx]][2]))
}

# Mapping the sensor measurement location to report dp01
Para$Flow$dp01$LvlTowr$co2Stor <- Para$Flow$dp01$LvlTowr$irgaStor 
Para$Flow$dp01$LvlTowr$h2oStor <- Para$Flow$dp01$LvlTowr$irgaStor
Para$Flow$dp01$LvlTowr$isoCo2 <- Para$Flow$dp01$LvlTowr$crdCo2
Para$Flow$dp01$LvlTowr$isoH2o <- Para$Flow$dp01$LvlTowr$crdH2o

```

## 3. Read in data!

Pass along the environment variables defined in section 2, 
then read in additional parameters from the HDF5 file.

We have found in testing that this section may run into trouble if 
Docker is not assigned sufficient memory in your system. If you 
find that this section hangs or errors out, try opening 
Docker -> Preferences -> Advanced and increasing the memory 
allotment.


```{r ingest,  message=F, warning=F}

# Create empty lists for data and quality flags
Data <- list()
qfqmFlag <- list()

# Index for the number of days iterated over, and empty list for outputs
numDate <- 0
tmpOut <- list()

# Loop over days in input data (in the example data here, there is 
# only one day)
for(Date in Para$Flow$DateOut) {
  numDate <- numDate + 1

  # Begin: read raw data from HDF5 file
  if(Para$Flow$Read == "hdf5") {

    # Create empty list for inputs
    inp <- list()

    # Loop over instruments
    for(idxSens in Sens){
     
      for(idxLvl in Para$Flow$dp01$LvlTowr[[idxSens]]){
        # Use data read function, assign result as temporary variable
        tmp <- eddy4R.base::wrap.hdf5.read(
          DirInpLoca = Para$Flow$DirInp,
          SiteLoca = Para$Flow$Loc,
          DateLoca = Date,
          VarLoca = idxSens,
          FreqLoca = Para$Flow$dp0p[[idxSens]]$FreqSamp,
          LvlTowr = idxLvl,
          DespLoca = DespLoca,
          MethMeas = "ecse"
        )


        # Read in quality flags from HDF5 file
        if(!idxSens %in% c("irgaValvLvl", "crdH2oValvVali", "crdCo2ValvLvl", "crdH2oValvLvl")){

          tmpQfqm <- eddy4R.base::def.hdf5.read.qfqm(
            DirInpLoca = Para$Flow$DirInp,
            SiteLoca = Para$Flow$Loc,
            DateLoca = Date,
            VarLoca = idxSens,
            FreqLoca = Para$Flow$dp0p[[idxSens]]$FreqSamp,
            LvlTowr = idxLvl,
            MethMeas = "ecse"
          )

          # Remove timestamp from flags, since timestamps will be 
          # saved elsewhere
          tmpQfqm <- tmpQfqm[,grep("time",names(tmpQfqm),invert = T), drop = FALSE]
        }
        
        # Copy results from temporary variables to inp
        # Time domain inclding unit assignment
        if(idxSens %in% c("irgaStor","crdCo2","crdH2o")) {

          inp$time <- tmp$time
          base::attr(x = inp$time, which = "unit") <- "YYYY-MM-DD hh:mm:ss.sss"
        }

        # Sensor data incl. unit assignment
        inp$data[[idxSens]][[idxLvl]] <- tmp$data
        for(idx in base::names(tmp$data)) base::attr(x = inp$data[[idxSens]][[idxLvl]][[idx]], which = "unit") <-
          base::attr(x = tmp$data, which = "unit")[[idx]]
        if(exists("tmpQfqm")) inp$qfqm[[idxSens]][[idxLvl]] <- data.frame(tmpQfqm)

        # Remove temporary variables
        rm(tmp)
        if(exists("tmpQfqm")) rm(tmpQfqm)
        invisible(gc())

        # End loop over instruments
      }
    }

    # Calculate derived quantities: daily extent, native resolution
    inp <- eddy4R.stor::wrap.prd.day.ecse(
      inpList = inp,
      Desp = DespLoca
    )

    # Print status message
    print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, 
                 ": perform daily processing in native resolution"))

  } 
  
  # Assign daily data and attributes
  # If loop is on the first day, create the attributes:
  if(numDate == 1) {

    for(idxSens in Sens){
      Data[[idxSens]] <- inp$data[[idxSens]]
      qfqmFlag[[idxSens]] <- inp$qfqm[[idxSens]]
    }

    # Time objects
    Data$time <- inp$time
    qfqmFlag$time <- inp$time

    # If loop is on any day after the first, append the attributes:
  } else {

    for(idxSens in Sens){
      Data[[idxSens]] <- rbind(Data[[idxSens]], inp[[idxSens]])
      qfqmFlag[[idxSens]] <- rbind(qfqmFlag[[idxSens]], inp$qfqm[[idxSens]])
    }

    Data$time <- rbind(Data$time, inp$time)
    qfqmFlag$time <- rbind(qfqmFlag$time, inp$time)

  # End attributes assignment
  }

  # Remove temporary list of input variables
  inp <- NULL
  invisible(gc())

}
# end: loop around Dates

```

## 4. eddy-covariance storage exchange (ECSE) level 1 data products (dp01) generation.

The first step is to get indices for different temporal resolutions at level 1 data products 
to determine where valid sampling and validation data are, using eddy4R.base::def.idx.agr(). 
Then the descriptive statistics, mean, minimum, maximum, variance, standard deviation, 
number of samples, as well as begin time and end time are calculated at different temporal resolutions 
as a list of data.frames, using eddy4R.stor::wrap.dp01.ecse(). The eddy4R.qaqc::wrap.dp01.qfqm.ecse() and eddy4R.ucrt::wrap.neon.dp01.ucrt.ecse() are used to calculate quality and uncertatiny metrics. 
Then concatenate results and HDF5 data formatting.


```{r dp01-process,  message=F, warning=F}

# Kick off with a time stamp when processing starts
print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, 
             " dp01 calculation begin"))

# Create empty list for working parameters and variables
wrk <- list()

# Determine which entries in Data correspond to desired aggregation interval
wrk$setData <- list()
for(idxFreq in c(1, 2, 30)){

  tmpIdx <- eddy4R.base::def.idx.agr(
    time = 1:86400,
    PrdAgr = (idxFreq * 60),
    FreqLoca = 1,
    MethIdx = "rglr"
  )

  wrk$setData[[paste0(idxFreq, "min")]]$Bgn <- tmpIdx$idxBgn
  wrk$setData[[paste0(idxFreq, "min")]]$End <- tmpIdx$idxEnd

}


# Create empty list for dp01, quality flag/ quality metric and uncertainty data
wrk$dp01 <- list()
wrk$qfqmOut <- list()
wrk$ucrt <- list()

  # Get the output version
  Para$Flow$VersDp <- paste0(Para$Flow$VersDp, "_", format(Sys.time(), "%Y%m%d_%H%M%S_%Z"))

  # Create empty list for input parameter for different sensors in dp01 data processing
  Para$Flow$dp01$Inp <- list()
  
  # For co2Stor during sampling period
  Para$Flow$dp01$Inp$data$co2Stor$samp <- list(
    "lvlMfcSampStor" = Para$Flow$dp01$LvlTowr$mfcSampStor,
    "lvlMfcValiStor" = NULL,
    "lvlValv" = Para$Flow$dp01$LvlTowr$irgaValvLvl,
    "PrdMeas" = 2,
    "lvlCrdH2oValvVali" = NULL
  )

  # For co2Stor during validating period
  Para$Flow$dp01$Inp$data$co2Stor$vali <- list(
    "lvlMfcSampStor" = Para$Flow$dp01$LvlTowr$mfcSampStor,
    "lvlMfcValiStor" = Para$Flow$dp01$LvlTowr$mfcValiStor,
    "lvlValv" = Para$Flow$dp01$LvlTowr$irgaValvLvl,
    "PrdMeas" = 2,
    "lvlCrdH2oValvVali" = NULL
  )

  # For h2oStor
  Para$Flow$dp01$Inp$data$h2oStor <- Para$Flow$dp01$Inp$data$co2Stor

  # Create empty list for input parameter for qfqm in dp01
  Para$Flow$dp01$Inp$qfqm <- list()
  for (idxTmp in names(Para$Flow$dp01$Inp$data)){
    Para$Flow$dp01$Inp$qfqm[[idxTmp]]$samp$lvlValvAux <- NULL
    Para$Flow$dp01$Inp$qfqm[[idxTmp]]$vali$lvlValvAux <- NULL
  }
  
  # Transfer the location parameter from dp01 to qfqm
  Para$Flow$dp01$Inp$qfqm$co2Stor$samp$lvlValvAux <- Para$Flow$dp01$LvlTowr$valvAux
  Para$Flow$dp01$Inp$qfqm$co2Stor$vali$lvlValvAux <- Para$Flow$dp01$LvlTowr$valvAux
  Para$Flow$dp01$Inp$qfqm$h2oStor <- Para$Flow$dp01$Inp$qfqm$co2Stor

  # Input parameter for ucrt in dp01
  Para$Flow$dp01$Inp$ucrt <- Para$Flow$dp01$Inp$data

  # Select data for different sampling, validating data at different window size (1 min, 2 min, 3 min, 9 min)
  for(idxDp01 in names(Para$Flow$dp01$Inp$data)){

    # Adding logic to run if there is the sensor data in dp0p
    if(MapSensDp01[[idxDp01]] %in% Sens){
      for(idxLvl in Para$Flow$dp01$LvlTowr[[idxDp01]]){

        # Determine different PrdAgr
        PrdAgr <- as.integer(resoTimeDp01[[idxDp01]]/60)

        # Determine sampling or validating data
        if (substring(idxLvl, 1, 3) == "000"){
          tmpTypeMeas <- "samp"
          if(idxDp01 == "isoH2o" ) PrdAgr <- as.integer(resoTimeDp01[[idxDp01]][c(2,3)]/60)

        } else {
          tmpTypeMeas <- "vali"
          if(idxDp01 == "isoH2o" ) PrdAgr <- as.integer(resoTimeDp01[[idxDp01]][c(1,3)]/60)

        }
        
        # Start dp01 processing for each aggregation period 
        for (idxPrdAgr in PrdAgr) {
          tmpDp01 <- list()
          tmpQfqmDp01 <- list()
          # dp01 processing
          print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, ": dp01 data processing ", idxDp01, " dp01 at measurment level of ", idxLvl))
          tmpDp01 <- eddy4R.stor::wrap.dp01.ecse(dp01 = idxDp01,
                                                 lvl = idxLvl,
                                                 lvlMfcSampStor = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlMfcSampStor,
                                                 lvlEnvHut = Para$Flow$dp01$LvlTowr$envHut,
                                                 lvlValv = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlValv,
                                                 lvlCrdH2oValvVali = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlCrdH2oValvVali,
                                                 data = Data,
                                                 qfInp = qfqmFlag,
                                                 TypeMeas = tmpTypeMeas,
                                                 PrdMeas = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$PrdMeas,
                                                 PrdAgr = idxPrdAgr,
                                                 idxTime = wrk$setData
          )
          
          
          # qfqm processing
          print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, ": dp01 qfqm processing ", idxDp01, " dp01 at measurment level of ", idxLvl))
          tmpQfqmDp01 <- eddy4R.qaqc::wrap.dp01.qfqm.ecse(dp01 = idxDp01,
                                                          RptExpd = TRUE,
                                                          lvl = idxLvl,
                                                          lvlMfcSampStor = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlMfcSampStor,
                                                          lvlMfcValiStor = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlMfcValiStor,
                                                          lvlEnvHut = Para$Flow$dp01$LvlTowr$envHut,
                                                          lvlValv = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlValv,
                                                          lvlCrdH2oValvVali = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$lvlCrdH2oValvVali,
                                                          lvlValvAux = Para$Flow$dp01$Inp$qfqm[[idxDp01]][[tmpTypeMeas]]$lvlValvAux,
                                                          data = Data,
                                                          qfInp = qfqmFlag,
                                                          TypeMeas = tmpTypeMeas,
                                                          PrdMeas = Para$Flow$dp01$Inp$data[[idxDp01]][[tmpTypeMeas]]$PrdMeas,
                                                          PrdAgr = idxPrdAgr,
                                                          idxTime = wrk$setData
          )
          
          #ucrt processing
          print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, ": dp01 ucrt processing ", idxDp01, " dp01 at measurment level of ", idxLvl))
          tmpUcrtDp01 <- eddy4R.ucrt::wrap.neon.dp01.ucrt.ecse(dp01 = idxDp01,
                                                               lvl = idxLvl,
                                                               lvlMfcSampStor = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$lvlMfcSampStor,
                                                               lvlEnvHut = Para$Flow$dp01$LvlTowr$envHut,
                                                               lvlValv = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$lvlValv,
                                                               lvlCrdH2oValvVali = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$lvlCrdH2oValvVali,
                                                               data = Data,
                                                               qfInp = qfqmFlag,
                                                               TypeMeas = tmpTypeMeas,
                                                               PrdMeas = Para$Flow$dp01$Inp$ucrt[[idxDp01]][[tmpTypeMeas]]$PrdMeas,
                                                               PrdAgr = idxPrdAgr,
                                                               idxTime = wrk$setData
          )
          
          # Rename idxLvl
          idxLvLPrdAgr <- paste0(idxLvl, "_", sprintf("%02d", idxPrdAgr), "m")
          
          # Copy results from temporary dataframe to working dataframe
          wrk$dp01[[idxDp01]][[idxLvLPrdAgr]] <- tmpDp01
          wrk$qfqmOut[[idxDp01]][[idxLvLPrdAgr]] <- tmpQfqmDp01
          wrk$ucrt[[idxDp01]][[idxLvLPrdAgr]] <- tmpUcrtDp01
          # Clean up
          base::invisible(base::gc())
        }# close idxPrdAgr

      }# end of loop around idxLvl
    }# end of whether there is a valid data
  }# end of loop around idxDp01

  # Clean up

  base::invisible(base::gc())

  # Concatenate results and HDF5 data formatting
  # Combine data product output into rpt
  rpt <- list()
  rpt$dp01$data <- eddy4R.base::def.hdf5.pack(inpList=wrk$dp01, MethMeas = "ecse", Dp ="Dp01")
  rpt$dp01$qfqm <- eddy4R.base::def.hdf5.pack(inpList=wrk$qfqmOut, MethMeas = "ecse", Dp ="Dp01")
  rpt$dp01$ucrt <- eddy4R.base::def.hdf5.pack(inpList=wrk$ucrt, MethMeas = "ecse", Dp ="Dp01")
  
  # Add standard error under uncertainty dataframe
  for(idxDp01 in c("co2Stor", "h2oStor")){
    for(idxLvl in base::names(rpt$dp01$ucrt[[idxDp01]])){
     
      for(idxSub in base::names(rpt$dp01$ucrt[[idxDp01]][[idxLvl]])){
       
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$se <- rpt$dp01$data[[idxDp01]][[idxLvl]][[idxSub]]$se
        # re-arrange order of variable
        tmp <- data.frame(mean= rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$mean,
                          vari = rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$vari,
                          se = rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$se,
                          timeBgn = as.character(rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$timeBgn),
                          timeEnd = as.character(rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]$timeEnd))
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[1]] <- tmp$mean
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[2]] <- tmp$vari
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[3]] <- tmp$se
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[4]] <- as.character(tmp$timeBgn)
        rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]][[5]] <- as.character(tmp$timeEnd)
        names(rpt$dp01$ucrt[[idxDp01]][[idxLvl]][[idxSub]]) <- names(tmp)
      };rm(tmp)
    }
  }

  # data: Transfer units
  for(idxDp in base::names(rpt$dp01$data)) {
    for(idxLvl in base::names(rpt$dp01$data[[idxDp]])){
      for(idxVar in base::names(rpt$dp01$data[[idxDp]][[idxLvl]])){
       
        # Remove standard error from data
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$se <- NULL

        #unit transfer
        base::attr(x = rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]], which = "unit") <-
          base::attr(x = wrk$dp01[[idxDp]][[idxLvl]][[1]]$mean[[idxVar]], which = "unit")
      }
    }

  }; rm(idxVar)

  # qfqm: transfer units
  for(idxDp in base::names(rpt$dp01$qfqm)) {
    for(idxLvl in base::names(rpt$dp01$qfqm[[idxDp]])){
      for(idxVar in base::names(rpt$dp01$qfqm[[idxDp]][[idxLvl]])){
        #unit transfer
        attributes(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <-
          attributes(wrk$qfqmOut[[idxDp]][[idxLvl]][[1]]$qfFinl[[idxVar]])$unit
      }
    }

  }; rm(idxVar)
  
  # Print screen
  print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, 
             " dp01 calculation complete!"))
  # Save image
  save.image("~/wrkdp01.RData")
  
```

## 5. ECSE level 2 data products (dp02) generation.

First read in ECSE level 1 temperature data; 
Then intepolate ECSE level 1 IRGA gas data and temperature data into continuous minutely data, using eddy4R.stor::def.itpl.time(); 
Then also intepolate ECSE Level 1 qfqm data; 
Then calcualte the time change rate, using eddy4R.stor::def.time.rate.diff();
Then concatenate results and HDF5 data formatting.


```{r dp02-process,  message=F, warning=F}
  # Print screen
  print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " dp02 calculation begin"))
  
  # Get input file directory
  FileInp <- Para$Flow$DirFilePara
  
  # List of all object names from HDF5
  listObjName <- base::paste(listPara$group, listPara$name, sep = "/")

  # Get HDF5 group structure
  listGrp <- listPara[listPara$otype == "H5I_GROUP",]
  # Get HDF5 group name
  listGrpName <- base::paste(listGrp$group, listGrp$name, sep = "/")

  # Get HDF5 data objects 
  listDataObj <- listPara[listPara$otype == "H5I_DATASET",]

  # Combining names for grabbing datasets
  listDataName <- base::paste(listDataObj$group, listDataObj$name, sep = "/")

  # Get LvlTowr for air temperature
  Para$Flow$dp01$LvlTowr$tempAirLvl <- unique(sapply(1:length(unique(listPara$group[(grep("tempAirLvl/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirLvl/",listPara$group))]), "tempAirLvl/")[[xx]][2]))
  Para$Flow$dp01$LvlTowr$tempAirTop <- unique(sapply(1:length(unique(listPara$group[(grep("tempAirTop/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirTop/",listPara$group))]), "tempAirTop/")[[xx]][2]))

  # Assign air temperature name
  exitDp01 <- c("tempAirLvl", "tempAirTop")
  # Get air temperature sub data product name 
  exitSubDp01 <- list()
  for(idxDp in exitDp01) {
    subName <- unique(listPara$group[(grep(paste0(idxDp, "/"),listPara$group))])[1]
    exitSubDp01[[idxDp]] <- listDataObj$name[listDataObj$group == subName]
  }
  
  # Transfer air temperature data and qfqm into rpt
  for(idxDp in exitDp01) {
    for(idxLvl in Para$Flow$dp01$LvlTowr[[idxDp]]){
      for(idxVar in exitSubDp01[[idxDp]]){
        # Combining names for grabbing datasets
        listDataNameTmp <- paste0("/",Para$Flow$Loc, "/", "dp01", "/", "data", "/", idxDp, "/", idxLvl, "/", idxVar)
        listQfqmNameTmp <- paste0("/",Para$Flow$Loc, "/", "dp01", "/", "qfqm", "/", idxDp, "/", idxLvl, "/", idxVar)

        # Read data from the input dp0p file
        listDataTmp <- base::lapply(listDataNameTmp, rhdf5::h5read, file = FileInp, read.attributes = TRUE)
        listQfqmTmp <- base::lapply(listQfqmNameTmp, rhdf5::h5read, file = FileInp, read.attributes = TRUE)

        # Apply group names to the list
        base::names(listDataTmp) <- idxVar
        base::names(listQfqmTmp) <- idxVar

        # Perform unit conversion
        listDataTmp[[idxVar]] <- base::suppressWarnings(eddy4R.base::def.unit.conv(data = listDataTmp[[idxVar]],
                                                                                   unitFrom = attributes(listDataTmp[[idxVar]])$unit,
                                                                                   unitTo = "intl",
                                                                                   MethGc = FALSE))
        # Add dp01 data into rpt
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$mean <- listDataTmp[[idxVar]]$mean
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$min <- listDataTmp[[idxVar]]$min
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$max <- listDataTmp[[idxVar]]$max
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$vari <- listDataTmp[[idxVar]]$vari
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$numSamp <- listDataTmp[[idxVar]]$numSamp
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$timeBgn <- base::as.POSIXct(listDataTmp[[idxVar]]$timeBgn, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]]$timeEnd <- base::as.POSIXct(listDataTmp[[idxVar]]$timeEnd, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        # Transfer unit attributes
        attributes(rpt$dp01$data[[idxDp]][[idxLvl]][[idxVar]])$unit <- attributes(listDataTmp[[idxVar]])$unit["mean"]

        # Add dp01 qfqm into rpt
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qmAlph <- listQfqmTmp[[idxVar]]$qmAlph
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qmBeta <- listQfqmTmp[[idxVar]]$qmBeta
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qfFinl <- listQfqmTmp[[idxVar]]$qfFinl
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$qfSci <- listQfqmTmp[[idxVar]]$qfSci
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$timeBgn <- base::as.POSIXct(listQfqmTmp[[idxVar]]$timeBgn, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]$timeEnd <- base::as.POSIXct(listQfqmTmp[[idxVar]]$timeEnd, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")
        # Assign unit attributes
        attributes(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <- "NA"
      }
    }
  }; rm(idxVar)

  # Define dp02 data product names
  dp02 <- c("co2Stor", "h2oStor", "tempStor")

  # Create a list of output frequencies for all dp02
  # unit [min]
  resoTimeDp02 <- list(
    "co2Stor" = c(30) * 60, 
    "h2oStor" = c(30) * 60,  
    "tempStor" = c(30) * 60 
  )
  
  # Create empty list for dp02 workflow parameters
  Para$Flow$dp02 <- list()
  # Get measurement location for each dp01 
  Para$Flow$dp02$LvlTowrReso <- list(
    "co2Stor" = unique(sapply(1:length(unique(listPara$group[(grep("irgaStor/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("irgaStor/",listPara$group))]), "irgaStor/")[[xx]][2])),
    #"000_010" "000_020" "000_030" "000_040" "co2Arch" "co2High" "co2Low"  "co2Med"  "co2Zero", #sensor in dp0p
    "tempStor" = c(unique(sapply(1:length(unique(listPara$group[(grep("tempAirLvl/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirLvl/",listPara$group))]), "tempAirLvl/")[[xx]][2])), unique(sapply(1:length(unique(listPara$group[(grep("tempAirTop/",listPara$group))])), function(xx) strsplit(unique(listPara$group[(grep("tempAirTop/",listPara$group))]), "tempAirTop/")[[xx]][2])))
   
  )

  # Add _02m 
  Para$Flow$dp02$LvlTowrReso$co2Stor <- paste0(Para$Flow$dp02$LvlTowrReso$co2Stor[which(substring(Para$Flow$dp02$LvlTowrReso$co2Stor, 1, 3) == "000")], "_02m")
  Para$Flow$dp02$LvlTowrReso$h2oStor <- Para$Flow$dp02$LvlTowrReso$co2Stor # output in dp01
  Para$Flow$dp02$LvlTowrReso$tempStor <- Para$Flow$dp02$LvlTowrReso$tempStor[which(substring(Para$Flow$dp02$LvlTowrReso$tempStor, 1, 3) == "000" & substring(Para$Flow$dp02$LvlTowrReso$tempStor, 9, 9) == "0")]

  # Create empty dp02 output names
  Para$Flow$dp02$Var <- list()
  Para$Flow$dp02$Var <- list(
    "co2Stor" = "rtioMoleDryCo2", 
    "h2oStor" = "rtioMoleDryH2o", 
    "tempStor" = "temp"  
  )

  # Mapping between dp01 and dp02 name
  mapDp02Dp01 <- list(
    "co2Stor" = "co2Stor",
    "h2oStor" = "h2oStor",
    "tempStor" = c("tempAirLvl", "tempAirTop")
  )

  # Create empty working list for dp02 output
  wrk$dp02 <- list()

  # Assign standard minutely time
  timeDp02 <- as.POSIXlt(seq.POSIXt(
    from = as.POSIXlt(paste(Date, " 00:00:00", sep=""), format="%Y-%m-%d %H:%M:%OS", tz="UTC"),
    to = as.POSIXlt(paste(Date, " 23:59:00", sep=""), format="%Y-%m-%d %H:%M:%OS", tz="UTC"),
    by = 60
  ), tz="UTC")

  # Convert time to fractional UTC time [h UTC]
  timeFracDp02 <- timeDp02$hour + timeDp02$min / 60 + timeDp02$sec / 3600

  # Define idxLvl at the tower top of tempStor
  idxLvlTempStor <- paste0("000_0", Para$Flow$Site$LvlMeasTow, "0_01m", sep="")
  
  # Assign the maximum gap time window
  WndwMax <- 40*60 #[s]
  
  # Start to calculate dp01 for each dp02
  for(idxDp in dp02){
  
    idxVar <- Para$Flow$dp02$Var[[idxDp]]
    wrk$dp02[[idxDp]] <- list()

    # Loop around different measurement levels as well as different aggregation time
    for(idxLvl in Para$Flow$dp02$LvlTowrReso[[idxDp]]){
      if(idxDp == "tempStor" & idxLvl == idxLvlTempStor) {
        tmpData <- rpt$dp01$data[[mapDp02Dp01[[idxDp]][2]]][[idxLvl]]
        tmpQfqm <- rpt$dp01$qfqm[[mapDp02Dp01[[idxDp]][2]]][[idxLvl]]
      } else {
        tmpData <- rpt$dp01$data[[mapDp02Dp01[[idxDp]][1]]][[idxLvl]]
        tmpQfqm <- rpt$dp01$qfqm[[mapDp02Dp01[[idxDp]][1]]][[idxLvl]]
      }

      # data intepolation data
      tmpItpl <- eddy4R.stor::def.itpl.time(
        dataInp = tmpData[[idxVar]],
        WndwMax = WndwMax, #maximum gap time [s]
        methItpl = "linear"
      )

      # qfqm interpolation
      # Assign actual time
      # Convert to POSIXct, so the full date and time can be stored in as accessed as a single vector
      timeDp01 <- as.POSIXlt(tmpData[[idxVar]]$timeBgn, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC")

      if(idxDp == "co2Stor" | idxDp == "h2oStor"){
        timeDp01 <- as.POSIXlt(timeDp01 + tmpData[[idxVar]]$numSamp/2*1/1, format="%Y-%m-%d %H:%M:%OS", tz="UTC")
      }

      # Convert time to fractional UTC time [h UTC]
      tmpQfqm$timeFrac <- timeDp01$hour + timeDp01$min / 60 + timeDp01$sec / 3600
      # Convert time to fractional day of year [DOY]
      tmpQfqm$DOYFrac <- timeDp01$yday + 1 +  tmpQfqm$timeFrac / 24
      # Clean up
      rm(timeDp01)

      # qfqm: determine which datapoints to assess
      setQfqmLgth <- length(which(!is.na(tmpQfqm[[idxVar]]$qfFinl)))

      # less than 2 values (minimum required by approx() function)
      if(setQfqmLgth < 2) {

        tmpQfqmItpl <- as.numeric(rep(1, length(timeDp02)))

        # interpolate actual qfqm data
      } else {

        tmpQfqmItpl <- zoo::na.approx(object=as.vector(tmpQfqm[[idxVar]]$qfFinl), x=#tmpData$timeFrac
                                        as.integer(tmpQfqm$timeFrac * 60)
                                      , xout=as.integer(timeFracDp02 * 60)
                                      , method = "linear", maxgap=WndwMax, na.rm=FALSE, rule=1, f=0)
        # replace qf that not = 0 to 1
        tmpQfqmItpl <- ifelse(tmpQfqmItpl != 0 | is.na(tmpQfqmItpl), 1, 0)
      }

  
      # Calculate the change rate 4 minutely average at the end minus the begining 4 min average 
      # Assign averaging period
      idxLvlReso <- paste0(substring(idxLvl, 1, 7), "_", as.integer(resoTimeDp02[[idxDp]] /60), "m")
      # Assign window period and incremental period
      PrdWndwAgr <- 4 * 60 #unit [s]
      PrdIncrAgr <- as.integer(resoTimeDp02[[idxDp]])
      
      # data: calculate time rate of change
      wrk$dp02[[idxDp]][[idxLvlReso]] <- eddy4R.stor::def.time.rate.diff(
        dataInp = tmpItpl,
        numDate = numDate,
        PrdWndwAgr = PrdWndwAgr,
        PrdIncrAgr = PrdIncrAgr,
        Date = substring(tmpData[[idxVar]]$timeBgn[1], 1, 10)
      )

      # qfqm: calculate time rate of change
      wrk$qfqmDp02[[idxDp]][[idxLvlReso]] <- eddy4R.stor::def.time.rate.diff(
        dataInp = tmpQfqmItpl,
        numDate = numDate,
        PrdWndwAgr = PrdWndwAgr,
        PrdIncrAgr = PrdIncrAgr,
        Date = substring(tmpData[[idxVar]]$timeBgn[1], 1, 10),
        qfqmFlag = TRUE

      )
    }
    print(idxDp)
  } 


  # Clean up
  base::invisible(gc())

  # End loop around aggregation interval
  # Print screen
  print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " dp02 calculation complete!"))
  # save.image
  save.image("~/wrkdp02.RData")

  # Concatenate results and HDF5 data formatting
  # Restructure output wrk$dp02:
  rpt$dp02$data <- eddy4R.base::def.hdf5.pack(inpList=wrk$dp02, MethMeas = "ecse", Dp ="Dp02")
  rpt$dp02$qfqm <- eddy4R.base::def.hdf5.pack(inpList=wrk$qfqmDp02, MethMeas = "ecse", Dp ="Dp02")

  # data: transfer units
  for(idxDp in base::names(rpt$dp02$data)) {
    for(idxLvl in base::names(rpt$dp02$data[[idxDp]])){
      for(idxVar in base::names(rpt$dp02$data[[idxDp]][[idxLvl]])){
        base::attr(x = rpt$dp02$data[[idxDp]][[idxLvl]][[idxVar]], which = "unit") <-
          paste0(base::attr(x = rpt$dp01$data[[mapDp02Dp01[[idxDp]][1]]][[1]][[Para$Flow$dp02$Var[[idxDp]]]], which = "unit"), " s-1")
      }
    }
  }

  #qfqm: transfer units
  for(idxDp in base::names(rpt$dp02$qfqm)) {
    for(idxLvl in base::names(rpt$dp02$qfqm[[idxDp]])){
      for(idxVar in base::names(rpt$dp02$qfqm[[idxDp]][[idxLvl]])){
        attributes(rpt$dp02$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <-
          attributes(rpt$dp01$qfqm[[mapDp02Dp01[[idxDp]][1]]][[1]][[Para$Flow$dp02$Var[[idxDp]]]])$unit
      }
    }
  }
  
```

## 6. ECSE level 3 data products (dp03) generation.

First vertically interpolate ECSE dp02 to get vertically resolved time change of rate, using eddy4R.stor::def.itpl.spce();
Then also intepolate ECSE Level 2 qfqm data; 
Then concatenate results and HDF5 data formatting.


```{r dp03-process,  message=F, warning=F}

# Print screen
print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " dp03 calculation begins!"))

# Assign dp03 names
dp03 <- c("co2Stor", "h2oStor", "tempStor")

# Define vertical resolution is 0.1 m
resoSpceOut <- 0.1

# Get the mesurement hight for each measurement level
lvlTowr <- Para$Flow$Site$DistZaxsLvlMeasTow

# Interpolate measurement hight in 0.1 m resolution
spceStad <- c(1:(max(as.numeric(lvlTowr))/resoSpceOut)) * resoSpceOut

# Convert the mesurement hight for each measurement level to numeric
spce <- as.numeric(lvlTowr)

# Create empty dp03 working list
wrk$dp03 <- list()

# Data calculation processing for each dp03
for(idxDp in dp03){
  idxVar <- names(rpt$dp02$data[[idxDp]][[1]])
  wrk$dp03[[idxDp]][[idxVar]] <- list()
  for(idxAgr in 1:length(rpt$dp02$data[[idxDp]][[1]][[1]][[1]])){
    # get dp02 data from each measurement level
    tmpData <- sapply(1:length(Para$Flow$dp02$LvlTowrReso[[idxDp]]), function(x) rpt$dp02$data[[idxDp]][[x]][[1]]$mean[idxAgr])
    # interpolate vertically
    tmpDp03 <- eddy4R.stor::def.itpl.spce(
      dataInp = tmpData,
      methItpl = "linear",
      resoSpceOut = resoSpceOut,
      lvlTowr = lvlTowr
    )
    # Copy results from temporary to wrk$dp03 
    if(idxAgr == 1) {
      wrk$dp03[[idxDp]][[idxVar]] <- tmpDp03
    } else {
      wrk$dp03[[idxDp]][[idxVar]] <- rbind(wrk$dp03[[idxDp]][[idxVar]], tmpDp03)
    }
  }# end of loop around idxAgr

  # Fomatting wrk$dp03 to dataframe
  wrk$dp03[[idxDp]][[idxVar]] <- data.frame(wrk$dp03[[idxDp]][[idxVar]])
  dimnames(wrk$dp03[[idxDp]][[idxVar]])[[2]] <- as.character(paste0(spceStad, " m"))
  # Add timestamp
  wrk$dp03[[idxDp]][[idxVar]]$timeBgn <- rpt$dp02$data[[idxDp]][[1]][[1]]$timeBgn
  wrk$dp03[[idxDp]][[idxVar]]$timeEnd <- rpt$dp02$data[[idxDp]][[1]][[1]]$timeEnd
} # end of loop around idxDp

# Create empty qfqm dp03 working list
wrk$qfqmDp03 <- list()
#qfqm processing
for(idxDp in dp03){
  idxVar <- names(rpt$dp02$qfqm[[idxDp]][[1]])
  wrk$qfqmDp03[[idxDp]][[idxVar]] <- list()
  for(idxAgr in 1:length(rpt$dp02$qfqm[[idxDp]][[1]][[1]][[1]])){
    # get dp02 data from each measurement level
    tmpQfqm <- sapply(1:length(Para$Flow$dp02$LvlTowrReso[[idxDp]]), function(x) rpt$dp02$qfqm[[idxDp]][[x]][[1]]$qfFinl[idxAgr])
    # interpolate vertically
    tmpQfqmDp03 <- zoo::na.approx(object=as.vector(tmpQfqm), 
                                  x = spce, 
                                  xout = spceStad,
                                  method = "linear",
                                  na.rm=TRUE
    )
    #fill in the data before 1st measurement level with 1st interpolation data
    tmpQfqmDp03 <- c(rep(tmpQfqmDp03[1], length(spceStad) - length(tmpQfqmDp03)), tmpQfqmDp03)
    #replace qf that not = 0 to 1
    tmpQfqmDp03 <- as.integer(ifelse(tmpQfqmDp03 != 0 | is.na(tmpQfqmDp03), 1, 0))

    # Gethering all data
    if(idxAgr == 1) {
      wrk$qfqmDp03[[idxDp]][[idxVar]] <- tmpQfqmDp03
    } else {
      wrk$qfqmDp03[[idxDp]][[idxVar]] <- rbind(wrk$qfqmDp03[[idxDp]][[idxVar]], tmpQfqmDp03)
    }
  }# end of loop around idxAgr
  
  # Fomatting wrk$qfqmDp03 to dataframe
  wrk$qfqmDp03[[idxDp]][[idxVar]] <- data.frame(wrk$qfqmDp03[[idxDp]][[idxVar]])
  dimnames(wrk$qfqmDp03[[idxDp]][[idxVar]])[[2]] <- as.character(paste0(spceStad, " m"))
  
  # Add timestamp
  wrk$qfqmDp03[[idxDp]][[idxVar]]$timeBgn <- rpt$dp02$qfqm[[idxDp]][[1]][[1]]$timeBgn
  wrk$qfqmDp03[[idxDp]][[idxVar]]$timeEnd <- rpt$dp02$qfqm[[idxDp]][[1]][[1]]$timeEnd

} # end of loop around idxDp

#Copy results from working list to report list
rpt$dp03$data <- wrk$dp03
rpt$dp03$qfqm <- wrk$qfqmDp03

#data: transfer units
for(idxDp in base::names(rpt$dp03$data)) {
   for(idxVar in base::names(rpt$dp03$data[[idxDp]])){
    base::attr(x = rpt$dp03$data[[idxDp]][[idxVar]], which = "unit") <-
      base::attr(x = rpt$dp02$data[[idxDp]][[1]][[idxVar]], which = "unit")
  }
}

#qfqm: transfer units
for(idxDp in base::names(rpt$dp03$qfqm)) {
  for(idxVar in base::names(rpt$dp03$qfqm[[idxDp]])){
    attributes(rpt$dp03$qfqm[[idxDp]][[idxVar]])$unit <-
      attributes(rpt$dp02$qfqm[[idxDp]][[1]][[idxVar]])$unit
  }
}
# Remove temporary dataframe
rm(tmpData, tmpQfqm)

# Print screen
print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " dp03 calculation complete!"))
 
 
```


## 7. ECSE level 4 data products (dp04) generation.

First spatial intergrate ECSE dp03 to get storage flux, using eddy4R.stor::def.flux.stor();
Then also calculate ECSE Level 3 qfqm to get dp04 qfqm; 
Then concatenate results and HDF5 data formatting;
Then performing unit conversion.


```{r dp04-process,  message=F, warning=F}
  # Print screen
  print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " dp04 calculation begin!"))
  # Create empty dp04 working list
  wrk$dp04 <- list()
  
  # Calculate flux for each data product
  for(idxDp in names(rpt$dp03$data)){
    idxVar <- names(rpt$dp03$data[[idxDp]])
    tmpData <- rpt$dp03$data[[idxDp]][[idxVar]]
    tmpDp04 <- eddy4R.stor::def.flux.stor(
      dataInp = tmpData,
      lvlTowr = LvlTowr
    )
    # Gethering all data
    wrk$dp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$mean <- tmpDp04$mean
    wrk$dp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeBgn <- tmpDp04$timeBgn
    wrk$dp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeEnd <- tmpDp04$timeEnd

  }

  #dp04 qfqm claculation
  wrk$qfqmDp04 <- list()
  for(idxDp in names(rpt$dp03$qfqm)){
    idxVar <- names(rpt$dp03$qfqm[[idxDp]])
    tmpQfqm <- rpt$dp03$qfqm[[idxDp]][[idxVar]]
    tmpQfqm$timeBgn <- NULL
    tmpQfqm$timeEnd <- NULL
    
    # Gethering all data
    wrk$qfqmDp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$qfFinl <- as.integer(apply(tmpQfqm, 1, function(x) ifelse(any(x==1),1,0)))
    wrk$qfqmDp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeBgn <- rpt$dp03$qfqm[[idxDp]][[idxVar]]$timeBgn
    wrk$qfqmDp04[[idxDp]][[paste0("fluxStor", substring(idxVar, 5, nchar(idxVar)))]]$timeEnd <- rpt$dp03$qfqm[[idxDp]][[idxVar]]$timeEnd

  }
  # Copy results from working list to report list
  rpt$dp04$data <- wrk$dp04
  rpt$dp04$qfqm <- wrk$qfqmDp04

  # data: transfer units
  for(idxDp in base::names(rpt$dp04$data)) {
      for(idxVar in base::names(rpt$dp04$data[[idxDp]])){
      tmpUnit <- base::attr(x = rpt$dp03$data[[idxDp]][[paste0("rate", substring(idxVar, 9, nchar(idxVar)))]], which = "unit")
      base::attr(x = rpt$dp04$data[[idxDp]][[idxVar]], which = "unit") <- paste0(substring(tmpUnit, 1, (nchar(tmpUnit) - 3)), "m ", substring(tmpUnit, (nchar(tmpUnit) - 2)))
    }
  }

  #qfqm: transfer units
  for(idxDp in base::names(rpt$dp04$qfqm)) {
    for(idxVar in base::names(rpt$dp04$qfqm[[idxDp]])){
      attributes(rpt$dp04$qfqm[[idxDp]][[idxVar]])$unit <-
        attributes(rpt$dp03$qfqm[[idxDp]][[paste0("rate", substring(idxVar, 9, nchar(idxVar)))]])$unit
    }
  }
  # Remove temporary dataframe
  rm(tmpData, tmpQfqm)

  # Assign new name for dp04 and sub dp04
  names(rpt$dp04$data$co2Stor) <- c("stor")
  names(rpt$dp04$data$h2oStor) <- c("stor")
  names(rpt$dp04$data$tempStor) <- c("stor")
  names(rpt$dp04$data) <- c("fluxCo2", "fluxH2o", "fluxTemp")

  # Assign new name for dp04 and sub dp04
  names(rpt$dp04$qfqm$co2Stor) <- c("stor")
  names(rpt$dp04$qfqm$h2oStor) <- c("stor")
  names(rpt$dp04$qfqm$tempStor) <- c("stor")
  names(rpt$dp04$qfqm) <- c("fluxCo2", "fluxH2o", "fluxTemp")

  # Performing unit conversion
  # data
  rpt <- eddy4R.base::wrap.unit.conv.out.ec(inpList = rpt, MethMeas = "ecse", MethType = "Data")
  # qfqm
  rpt <- eddy4R.base::wrap.unit.conv.out.ec(inpList = rpt, MethMeas = "ecse", MethType = "Qfqm")
  # ucrt
  rpt <- eddy4R.base::wrap.unit.conv.out.ec(inpList = rpt, MethMeas = "ecse", MethType = "Ucrt")

  # Print screen
  print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " dp04 calculation complete!"))
  
  
```


## 8. HDF5 write out

Lastly, we prepare the data for output and write it to the dp01-dp04 
output HDF5 file. We first create the skeleton structure of the NEON HDF5 file. 
Then we extracting dp01 structure from input dp0p file using eddy4R.base::def.hdf5.extr ().
Then write attribute and the output to the NEON ECSE dp01-do04 HDF5 file.


```{r hdf5-output,  message=F, warning=F}

  # Create structure for HDF5
  # Print screen
  print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " : HDF5 generation"))
  
  # Get output directory
  DirHdf5Out <- Para$Flow$DirOut

  # Fomatting Date for file names
  dateFileInp <- gsub(pattern = "-", replacement = "", x = Date)

  # Check to see if the directory exists, if not create the directory. 
  # Recursive required to write nested file directories
  if (dir.exists(DirHdf5Out) == FALSE) dir.create(DirHdf5Out, recursive = TRUE)

  # Write out metadata at different hdf5 levels
  # Writing metadata from input dp0p file to output dp01 file for both basic and expand package
  for (idxPack in c("expanded", "basic")){
    #Create the file, create a class
    idFile <- rhdf5::H5Fcreate(paste0(DirHdf5Out,"/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"))
    
    # Create a group level (Site level)
    idSite <- rhdf5::H5Gcreate(idFile, Para$Flow$Loc)

    # Create dp02 structure
    lapply(c("dp02"), function(n1) {
      idn1 <- rhdf5::H5Gcreate(idSite, n1)
      lapply(names(rpt[[n1]]), function(n2) {
        idn2 <- rhdf5::H5Gcreate(idn1, n2)
        lapply(names(rpt[[n1]][[n2]]), function(n3) {
          idn3 <- rhdf5::H5Gcreate(idn2, n3)
          lapply(names(rpt[[n1]][[n2]][[n3]]), function(n4) {
            rhdf5::H5Gcreate(idn3, n4)
        }) } ) }) })#end of lapply

    # Create dp03 and dp04 structure
    lapply(c("dp03", "dp04"), function(n1) {
      idn1 <- rhdf5::H5Gcreate(idSite, n1)
      lapply(names(rpt[[n1]]), function(n2) {
        idn2 <- rhdf5::H5Gcreate(idn1, n2)
        lapply(names(rpt[[n1]][[n2]]), function(n3) {
          idn3 <- rhdf5::H5Gcreate(idn2, n3)
      })})} )#end of lapply

    rhdf5::H5Gclose(idSite)
    rhdf5::H5Fclose(idFile)
    rhdf5::h5closeAll()

    # Extract dp01 structure from input dp0p
    eddy4R.base::def.hdf5.extr(FileInp = Para$Flow$DirFilePara,
                               FileOut = paste0(Para$Flow$DirOut, "/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"),
                               dp01 = c("co2Stor", "h2oStor", "isoCo2", "isoH2o"))
    
    # Open the output file HDF5 link
    idFile <- rhdf5::H5Fopen(paste0(Para$Flow$DirOut, "/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"))

    # Write the attributes to the new file
    listAttr <- list()
    listAttr[[paste0("//", Para$Flow$Loc)]] <- Para$Flow$Site
    #dp01
    for(idxDp in c("co2Stor", "h2oStor", "isoCo2", "isoH2o", "tempAirLvl", "tempAirTop")){
      
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      #qfqm
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]])
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      #ucrt
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp01[[idxDp]] )

      if(idxDp %in% c("co2Stor", "h2oStor", "isoCo2")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", as.integer(resoTimeDp01[[idxDp]][2] ))
      if(idxDp %in% c("isoH2o")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/data/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", "NA", as.integer(resoTimeDp01[[idxDp]][3]))
      #qfqm
      if(idxDp %in% c("co2Stor", "h2oStor", "isoCo2")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", as.integer(resoTimeDp01[[idxDp]][2]))
      if(idxDp %in% c("isoH2o")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", "NA", as.integer(resoTimeDp01[[idxDp]][3]))
      #ucrt
      if(idxDp %in% c("co2Stor", "h2oStor", "isoCo2")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", as.integer(resoTimeDp01[[idxDp]][2]))
      if(idxDp %in% c("isoH2o")) listAttr[[paste0("/", Para$Flow$Loc, "/dp01/ucrt/", idxDp)]][["PrdIncrAgrDflt"]] <- c("NA", "NA", as.integer(resoTimeDp01[[idxDp]][3]))
    }

    #dp02 and dp02
    for(idxDp in c("co2Stor", "h2oStor", "tempStor")){
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/data/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/qfqm/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]])
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp02/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]])
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/data/", idxDp)]][["SpceWndwAgrDflt"]] <- resoSpceOut
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp02[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp03/qfqm/", idxDp)]][["SpceWndwAgrDflt"]] <- resoSpceOut
    }

    # Assign averaging period
    resoTimeDp04 <- list(
      "fluxCo2" = c(30) * 60, #output node in dp04
      "fluxH2o" = c(30) * 60,  #output node in dp04
      "fluxTemp" = c(30) *60  #output node in dp04
    )
    # Write dp04 attribuite
    for(idxDp in c("fluxCo2", "fluxH2o", "fluxTemp")){
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/data/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/qfqm/", idxDp)]] <- list()
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/data/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/data/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/qfqm/", idxDp)]][["PrdIncrAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )
      listAttr[[paste0("/", Para$Flow$Loc, "/dp04/qfqm/", idxDp)]][["PrdWndwAgrDflt"]] <- as.integer(resoTimeDp04[[idxDp]] )

    }
    # Get idData
    idData <- rhdf5::H5Oopen(idFile, paste0("//", Para$Flow$Loc))

    # Write the attributes to the new file
    lapply(names(listAttr), function(x){
      idData <- rhdf5::H5Oopen(idFile, x)
      base::lapply(names(listAttr[[x]]), function(y){
        #C heck for logicals and convert to numeric
        if(is.logical(listAttr[[x]][[y]])) listAttr[[x]][[y]] <<- as.numeric(listAttr[[x]][[y]])
        rhdf5::h5writeAttribute(attr = listAttr[[x]][[y]], h5obj = idData, name = y)
      })
    })

    # Empty dp01 for dp which already exits in input dp0p HDF5
    for (idxDp01 in c("tempAirLvl", "tempAirTop")){
      rpt$dp01$data[[idxDp01]] <- NULL
      rpt$dp01$qfqm[[idxDp01]] <- NULL
    }
    
    #Write output to hdf5 file

    idFile <- rhdf5::H5Fopen(paste0(Para$Flow$DirOut, "/",Para$Flow$FileOutBase, ".", Date, ".", idxPack,".h5"))

    # Write output to hdf5 file for data dp01 and dp02
    lapply(c("dp01", "dp02"), function(idxLvlDp) {
      lapply(names(rpt[[idxLvlDp]]$data), function(idxDp) {
        lapply(names(rpt[[idxLvlDp]]$data[[idxDp]]), function(idxLvLReso) {
          nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/data/",idxDp,"/",idxLvLReso))
          lapply(names(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]]), function(idxVar){
            rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
            if (!is.null(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]][[idxVar]])$unit) == TRUE){
              dgid <- rhdf5::H5Dopen(nid, idxVar)
              rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxLvLReso]][[idxVar]])$unit, h5obj = dgid, name = "unit")
            }})} ) }) })

    # Only output qfFinl in the basic package
    if (idxPack %in% "basic"){
      for(idxDp in base::names(rpt$dp01$qfqm)) {
        for(idxLvl in base::names(rpt$dp01$qfqm[[idxDp]])){
           for(idxVar in base::names(rpt$dp01$qfqm[[idxDp]][[idxLvl]])){
            #output only qfFinl
            rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]] <- rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]][which((names(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]]) %in% c("qfFinl",  "timeBgn", "timeEnd")))]
            #unit transfer
            attributes(rpt$dp01$qfqm[[idxDp]][[idxLvl]][[idxVar]])$unit <-
              attributes(wrk$qfqmOut[[idxDp]][[idxLvl]][[1]]$qfFinl[[idxVar]])$unit
          }
        }
      }; rm(idxVar)
    }# close if statment of idxPack = "basic

    # Write output to hdf5 file for qfqm dp01 and dp02
    lapply(c("dp01", "dp02"), function(idxLvlDp) {
      lapply(names(rpt[[idxLvlDp]]$qfqm), function(idxDp) {
        lapply(names(rpt[[idxLvlDp]]$qfqm[[idxDp]]), function(idxLvLReso) {
          nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/qfqm/",idxDp,"/",idxLvLReso))
          lapply(names(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]]), function(idxVar){
            rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
            if (!is.null(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]][[idxVar]])$unit) == TRUE){
              dgid <- rhdf5::H5Dopen(nid, idxVar)
              rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxLvLReso]][[idxVar]])$unit, h5obj = dgid, name = "unit")
            } })} )})})

    # Write output to hdf5 file for ucrt dp01
    lapply(c("dp01"), function(idxLvlDp) {
      lapply(names(rpt[[idxLvlDp]]$ucrt), function(idxDp) {
        lapply(names(rpt[[idxLvlDp]]$ucrt[[idxDp]]), function(idxLvLReso) {
          nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/ucrt/",idxDp,"/",idxLvLReso))
          lapply(names(rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]]), function(idxVar){
            rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
            if (!is.null(attributes(rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]][[idxVar]])$unit) == TRUE){
              dgid <- rhdf5::H5Dopen(nid, idxVar)
              rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$ucrt[[idxDp]][[idxLvLReso]][[idxVar]])$unit, h5obj = dgid, name = "unit")
            }})})})})

    # Write output to hdf5 file for data dp03 and dp04
    lapply(c("dp03", "dp04"), function(idxLvlDp) {
      lapply(names(rpt[[idxLvlDp]]$data), function(idxDp) {
        nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/data/",idxDp))
        lapply(names(rpt[[idxLvlDp]]$data[[idxDp]]), function(idxVar) {
          rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$data[[idxDp]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
          if (!is.null(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxVar]])$unit) == TRUE){
            dgid <- rhdf5::H5Dopen(nid, idxVar)
            rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$data[[idxDp]][[idxVar]])$unit, h5obj = dgid, name = "unit")
          }})})})

    # Write output to hdf5 file for qfqm dp03 and dp04
    lapply(c("dp03", "dp04"), function(idxLvlDp) {
      lapply(names(rpt[[idxLvlDp]]$qfqm), function(idxDp) {
        nid <- rhdf5::H5Gopen(idFile, paste0("/", Para$Flow$Loc, "/", idxLvlDp,"/qfqm/",idxDp))
        lapply(names(rpt[[idxLvlDp]]$qfqm[[idxDp]]), function(idxVar) {
          rhdf5::h5writeDataset.data.frame(obj = rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxVar]], h5loc = nid, name = idxVar, DataFrameAsCompound = TRUE)
          if (!is.null(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxVar]])$unit) == TRUE){
            dgid <- rhdf5::H5Dopen(nid, idxVar)
            rhdf5::h5writeAttribute(attributes(rpt[[idxLvlDp]]$qfqm[[idxDp]][[idxVar]])$unit, h5obj = dgid, name = "unit")
          }})})})

    rhdf5::h5closeAll()
  }#closed loop for idxPack

  # Print screen
  print(paste0(format(Sys.time(), "%F %T"), ": dataset ", Date, " : HDF5 generation complete!"))

```
