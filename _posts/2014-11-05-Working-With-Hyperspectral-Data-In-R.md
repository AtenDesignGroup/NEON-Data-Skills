---
layout: post
title: "R: Intro to Working with Hyperspectral Remote Sensing Data in HDF5 Format in R"
date:   2014-11-26 20:49:52
authors: Edmund Hart, Leah A. Wasser
categories: [remote-sensing]
category: remote-sensing
tags: [hyperspectral-remote-sensing,R,HDF5]
mainTag: hyperspectral-remote-sensing
description: "Open up and explore a hyperspectral dataset stored in HDF5 format in R. Learn about the power of data slicing in HDF5. Slice our band subsets of the data and create and visualize one band." 
image:
  feature: hierarchy_folder_purple.png
  credit: The Artistry of Colin Williams, NEON
  creditlink: http://www.neoninc.org
permalink: /HDF5/Imaging-Spectroscopy-HDF5-In-R/
code1: hyperspectral_HDF5_Data_R.R
comments: true
---

<section id="table-of-contents" class="toc">
  <header>
    <h3>Contents</h3>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->

<div id="objectives">
<strong>R Skill Level:</strong> Intermediate

<h3>Goals / Objectives</h3>
After completing this activity, you will:
<ol>
<li>Understand how HDF5 data can be used to store spatial data and the associated benefits of this format when working with large spatial data cubes.</li>
<li>Know how to extract metadata from HDF5 files.</li>
<li>Know how to slice or subset HDF5 data. You will extract one band of pixels. </li>
<li>Know how to plot a matrix as an image and a raster.</li>
<li>Know how to export a final Geotiff (spatially projected) that can be used both in further analysis and in common GIS tools like QGIS.</li>
</ol>

<h3>What you'll Need</h3>
<ul>
<li>R or R studio to write your code.</li>
<li>The latest version of RHDF5 packag for R.</li>
</ul>
SJER_140123_chip.h5

<h3>Data to Download</h3>
<a href="http://neonhighered.org/Data/HDF5/SJER_140123_chip.h5" class="btn"> DOWNLOAD the NEON Imaging Spectrometer Data (HDF5) Format</a>. 
<p>The data in this HDF5 file were collected over the San Joachim field site located in California (NEON Domain 17) and processed at NEON headquarters. The entire dataset can be access by request from the NEON website.</p>  
</div>


##About Imaging Spectroscopy (hyperspectral) Remote Sensing Data

The electromagnetic spectrum is composed of thousands of bands representing different types of light energy. Imaging spectrometers break the electromagnetic spectrum into groups of bands that support classification of objects by their spectral properties on the earth's surface. Hyperspectral data consists of many bands - up to hundreds of bands - that cover the electromagnetic spectrum.

The NEON imaging spectrometer (NIS) collects data within the 380nm to 2510nm portions of the electromagnetic spectrum within bands that are approximately 5nm in width. This results in a hyperspectral data cube that contains approximately 428 bands - which means BIG DATA. 

![Google maps view of the same general area.]({{ site.baseurl }}\images\hyperspectral\DataCube.png)


<figure>
	<a href="{{ site.baseurl }}/images/hyperspectral/DataCube.png"><img src="{{ site.baseurl }}/images/hyperspectral/DataCube.png"></a>
	<figcaption>A data cube of NEON hyperspectral data. Each layer in the cube represents a band.</figcaption>
</figure>

The diverse and flexible HDF5 file format supports spatial data. It is ideal for working with large spatial data cubes such as those generated by imaging spectrometers given both its ability to natively compress the data (making it smaller) and its support of data slicing (extracting only the portions of the data that you need to work with rather than reading the entire dataset into memory).

##About This Activity
In this activity we will explore reading a HDF5 data that contains spatial raster data into `R`. Please be sure that you have *atleast* version 2.10 of `rhdf5` installed. Use: `packageVersion("rhdf5")` to check the package version. If you need to update `rhdf5`, use the following code:

	source("http://bioconductor.org/biocLite.R")
	biocLite("rhdf5")

<i class="fa fa-star"></i> **Data Tip:** To update all packages installed in `R`, use `update.packages()`.
{: .notice}


##1. Read HDF5 data into R
We will use the `raster` and `rhdf5` libraries to read in the HDF5 file that contains hyperspectral data for the <a href="http://neoninc.org/science-design/field-sites/san-joaquin" target="_blank">NEON San Joaquin field site</a>. Let's start by calling the needed libraries and reading in our NEON HDF5 file.  
 
    #r Load `raster` and `rhdf5` packages and read NIS data into R
    library(raster)
    library(rhdf5)
    #load our file 
    f <- '/path/to/your/data/SJER_140123_chip.h5'
    #look at the HDF5 file structure 
    h5ls(f,all=T)

When you look at the structure of the data, take note of the `map info dataset`, the `spatial info` folder, and the `wavelengths` and `reflectance` datasets. The `spatial info` folder contains the spatial attributes of the data including its Coordinate Reference System (CRS). The CRS represents how it's physically located on the earth. The `wavelengths` dataset contains the middle wavelength values for each band in the data. The reflectance dataset contains the image data that we will use for both data processing and visualization. 

We can use the `h5readAttributes` function to read and extract metadata from the HDF5 file. Let's start by reading in the spatial information.

 
    #r get spatial info and map info using the h5readAttributes function 
    #notes - this function was developed by the infamous Ted Hart
	spinfo <- h5readAttributes(f,"spatialInfo"))


Next, let's read in the wavelength center associated with each band in the hdf5 file. What wavelength is band 19 associated with? (hint: look at the wavelengths vector that we just imported and check out the data located at index 19)

    #read in the wavelength information from the Hdf5 file
    wavelengths<- h5read(f,"wavelength",index=list(1:426,1))

<i class="fa fa-star"></i> **Data Tip: Bands and Wavelengths** A *band* represents a group of wavelengths. For example, the wavelength values between 800nm and 805nm might be one band as captured by an imaging spectrometer. The imaging spectrometer collects reflected light energy in a pixel for light in that band. Often when you work with a multi or hyperspectral dataset, the band information is reported as the center wavelength value. This value represents the center point value of the wavelengths represented in that  band. Thus in a band spanning 800-805 nm, the center would be 802.5). The full width half max (FWHM) will also be reported. This value represents the spread of the band around that center point. So, a band that covers 800nm-805nm might have a FWHM of 2.5 and a wavelength value of 802.5. 
{: .notice}

Our HDF5 dataset contains more information than we need to work with. We don't need to process all 426 bands. The HDF5 formal allows us to slice the data - quickly extracting the subset that we need to process. Let's extract one of the green bands in our dataset - band 34. By the way - what is the center wavelength value associated with band 34? hint `wavelengths[34]`

    #Extract or "slice" data for band 34 from the HDF5 file
	b34<- h5read(f,"Reflectance",index=list(1:477,1:502,34))
	

###A Note About Data Slicing in HDF5
One of the benefits of HDF5 files is data slicing. Slicing means that you can extract and work with subsets of the data rather than reading in the entire dataset into memory. Thus, in this case, we can extract and plot the green band without reading in all 426 bands of information. The ability to slice large datasets, makes HDF5 ideal for working with big data. 	


Next, let's convert our data from an array (more than 2 dimensions) to a matrix (just 2 dimensions). We need to have our data in a matrix format to plot it.

    #Convert from array to matrix
    b34 <- b34[,,1]
    

<i class="fa fa-star"></i> **Data Tip: Arrays vs. Matrices** Arrays are matrices with more than 2 dimensions. Put the other way: matrices are arrays with only 2 dimensions. Arrays can have any number of dimensions one, two, ten or more. When we say dimension, we are talking about the "z" associated with the data.
{: .notice} 

Here is a matrix that is 4 x 3 in size (4 rows and 3 columns):

| species 1      | species 2 | species 3 |
|----------------|-----------|-----------|
| total number   | 23        | 45        |
| average weight | 14        | 5         |
| average length | 2.4       | 3.5       |
| average height | 32        | 12        |

<i class="fa fa-star"></i> **Data Tip: Dimensions in Arrays** An array might add an additional dimension to this dataset. For example, let's say that we collected this same set of species data for every day in a 30 day month. We might then have a matrix like the one above for each day for a total of 30 days making a 4 x 3 x 30 array (this dataset has more than 2 dimensions).
{: .notice}

# image showing matrix vs array
#http://www.statmethods.net/input/datatypes.html

Next, let's look at the metadata for the reflectance data. When we do this, take note of 1) the scale factor and 2) the data ignore value.
    
    # look at the metadata for the reflectance dataset
    h5readAttributes(f,"Reflectance")
    

Let's plot the band 34 data. Plotting spatial data as a visual "data check" is a good idea to make sure processing is being performed correctly and all is well with the image. 

    image(b34)
    #note - when R brings in the matrix, the dimensions are read in reverse order
    
<figure class="half">
    <a href="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"><img src="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"></a>
    <a href="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"><img src="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"></a>
    <figcaption>On the left is the RGB image showing what the site should look like. On the right are our results. Notice that the data are flipped. This is caused by how R reads in the dimensions of our HDF5 file.</figcaption>
</figure>    
    
	#We need to transpose x and y values in order for our final image to plot properly
	b34<-t(b34)

<i class="fa fa-star"></i> **Data Tip: Transpose** in HDF5 view, notice that the image dimensions for this file are bands x rows x columns. However, when R reads in the dataset, it reads them as columns x bands x rows. The data thus come in flipped. We can quickly transpose the data to correct for this using the `t` or `transpose` command in `R`.
{: .notice} 

What do you notice about the image? Its a bit dark and lacking any detail. What could be causing this? Let's look at the distribution of reflectance values in our data to figure out what is going on.

    #Plot range of reflectance values as a histogram to view range
    #and distribution of values.
    hist(b34,breaks=40,col="darkmagenta")
    #View values between 0 and 5000
    hist(b34,breaks=40,col="darkmagenta",xlim = c(0, 5000))
    hist(b34, breaks=40,col="darkmagenta",xlim = c(5000, 15000),ylim=c(0,100))
    
Notice in the data that there are some larger reflectance values (>5,000) that represent a smaller number of pixels. These pixels are skewing how the image renders.

Also what do reflectance values between 1-15,000 actually mean? Reflectance values are always between 0-1. The data scale factor tells us to divide all reflectance values by 1000. Thus a value of 500 equates to a reflectance of 0.50. Storing data as integers (without decimal places) compared to floating points (with decimal places) creates a smaller file. You will see this done often when working with remote sensing data.  
    



<i class="fa fa-star"></i> **Data Tip: Scale factors**The scale factor represents a value that you multiply or divide the data by. This is often used to reduce files sizes. In this case, reflectance values range from 0-1 but we have values from 1-15,000. The scale factor is added to compress the data. decimal places necessitate the use of the "float" numeric data type which makes the file size large. If we divide all of the values by 1,000, we will get data within the 0-1 range. We can then deduct that values over 1 are not good reflectance values. 
{: .notice}


<i class="fa fa-star"></i> **Data Tip: Reflectance Values and Image Stretch** MORE WILL GO HERE #something about image stretching
{: .notice}



    
Remember that the metadata for the `Reflectance` dataset designated 15,000 as `data ignore value`. Thus, let's set all pixels with a value > 14,999 to `NA` (no value). If we do this, R won't try to render these pixels.
	
	b34[b34 = 15000] <- NA

<i class="fa fa-star"></i> **Data Tip: Data Ignore Value** Image data in raster format will often contain a data ignore value and a scale factor. The data ignore value represents pixels where there are no data. Among other causes, no data values may be attributed to the sensor not collecting data in that area of the image or to processing results which yield null values. 
{: .notice}

Our image still looks dark because R is trying to render all reflectance values between 0 and 14999 as if they were distributed equally in the histogram. However we know they are not distributed equally. There are many more values between 0-5000 then there are values >5000. The proper way to adjust our data would be what's called an `image stretch`. We will learn how to stretch our image data, later. For now, let's run a log on the pixel reflectance values to factor out those larger values. 

	image(log(b34))
	

The log applied to our image increases the contrast making it look more like an image. However, look at the images below. The top one is what our log adjusted image looks like when plotted. The bottom on is an RGB version of the same image. Notice a difference? 


<figure class="third">
    <a href="https://www.google.com/maps/place/37%C2%B007'40.2%22N+119%C2%B044'26.9%22W/@37.1243731,-119.7370126,803m/data=!3m1!1e3!4m2!3m1!1s0x0:0x0" target="_blank"><img src="{{ site.baseurl }}/images/hyperspectral/SJERImage.png"></a>
    <a href="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"><img src="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"></a>
    <a href="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"><img src="{{ site.baseurl }}/images/hyperspectral/SJER_RGB.png"></a>
    <figcaption>On the left is the orientation of the actual image. On the right  describing these two images.</figcaption>
</figure>


The orientation is off in our log adjusted image. This is because `R` reads in matrices starting from the upper left hand corner. Whereas, most rasters read pixels starting from the lower left hand corner. In the next section, we will deal with this issue by creating a proper georeferenced (spatiall located) raster in R. The raster format will read in pixels following the same methods as other GIS and imaging processing software like QGIS and ENVI do.



##2. Create a Georeferenced Raster
Next, we will create a proper raster using the `b34` matrix. The raster format will allow us to define and manage:

* image stretch
* coordinate reference system / spatial reference and
* resolution

It will also account for the orientation issue discussed above.
 
To create a raster in R, we need a few pieces of information, including: 

* The coordinate reference system (CRS)
* The location of the first pixel (located in the lower left hand corner of the raster). 
* The resolution or size of each pixel in the data. 

First let's grab the spatial information that we need from the HDF5 file. The CRS and associated information that is needed is stored in the `map info` dataset. The map info string looks something like this: `"UTM,1.000,1.000,256521.000,4112571.000,1.000000e+000,1.000000e+000,11,North,WGS-84,units=Meters" ` Notice that this information is separated by commas. We can use the `strsplit` command in R to extract each element into a vector. The elements are position 4 and 5 represent the lower left hand corner of the raster. We need this information to define the raster's extent.

	#Populate the raster image extent value. 
	#get the map info, split out elements
	mapInfo<-h5read(f,"map info")
	#Extract each element of the map info information so we can extract the lower left hand corner coordinates.
	mapInfo<-unlist(strsplit(mapInfo, ","))

Next we define the extents of our raster. The extents will be used to calculate the raster's resolution. The lower left hand corner is located at mapInfo[4:5]. We can define the final raster dataset extent by adding the number of rows to the Y lower left hand corner coordinate and the number of columns in the `Reflectance` dataset to the X lower left hand corner coordinate.    

	#define extents of the data using metadata and matrix attributes
	xMN=as.numeric(mapInfo[4])
	xMX=(xMN+(ncol(b34)))
	yMN=as.numeric(mapInfo[5]) 
	yMX=(yMN+(nrow(b34)))     
	rasExt <- extent(xMN,xMX,yMN,yMX)

	#define final raster with projection info 
	b34r<-raster(b34, 
            crs=(spinfo$projdef))

	#assign the spatial extent to the raster
	extent(b34r) <- rasExt
	#look at raster attribtues
	b34r

We've now created a raster from band 34 reflectance data. We can plot that data if we want using the `plot` command. 

	writeRaster(b34r,file="band34.tif",overwrite=TRUE)




  
