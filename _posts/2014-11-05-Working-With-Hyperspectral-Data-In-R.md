---
layout: post
title: "R: Working with HDF5 Format Hyperspectral Remote Sensing Data in in R"
date:   2014-11-26 20:49:52
authors: Edmund Hart, Leah A. Wasser
categories: [remote-sensing]
category: remote-sensing
tags: [hyperspectral-remote-sensing,R,HDF5]
mainTag: hyperspectral-imaging
description: "Open up and explore hyperspectral imagery in HDF format R."
code1: 
image:
  feature: hierarchy_folder_purple.png
  credit: The Artistry of Colin Williams, NEON
  creditlink: http://www.neoninc.org
permalink: /HDF5/Imaging-Spectroscopy-HDF5-In-R/
code1: hyperspectral_HDF5_Data_R.R

---

<section id="table-of-contents" class="toc">
  <header>
    <h3>Contents</h3>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->

<div id="objectives">
<strong>R Skill Level:</strong> Intermediate


<h3>Goals / Objectives</h3>
After completing this activity, you will:
<ol>
<li>Understand how HDF5 data can be used to store spatial data and the associated benefits of this format when working with large spatial data cubes.</li>
<li>Know how to subset spatial data contained within HDF5 files.</li>
<li>Know how to extract several bands, create RGB images and perform Raster raster math.</li>
<li>Know how to export a final Geotiff (spatially projected) that can be used both in further analysis and in common GIS tools like QGIS.</li>
</ol>

<h3>What you'll Need</h3>
<ul>
<li>R or R studio to write your code.</li>
<li>the latest version of RHDF5.</li>
</ul>


<h3>Data to Download</h3>
<p> Be sure to download the NEON Imaging Spectrometer data subset.</p>
<a href="http://neonhighered.org/data/SJER_140123_chip.h5"> ->> RIGHT CLICK HERE TO DOWNLOAD <<- </a>. These data were collected over the San Joachim field site located in California (NEON Domain 17). 

</div>


##About Imaging Spectroscopy (hyperspectral) remote sensing data

The electromagnetic spectrum is composed of thousands of bands representing different types of light energy. Imaging spectrometers break the electromagnetic spectrum into groups of bands that support classification of objects by their spectral properties on the earth's surface. Hyperspectral data consists of many bands - up to hundreds of bands - that cover the electromagnetic spectrum.

The NEON imaging spectrometer (NIS) collects data within the 3XXnm to 25XXnm of the electromagnetic spectrums within bands that are approximately 5nm in width. This results in a hyperspectral data cube that contains approximately 426 bands - which means BIG DATA. So big in fact that a X by X tile that cover xxx areas on the earth surface using 1 m pixels is already XXXmb in size.

The HDF5 file format supports not only temporal data, it also supports spatial data. And it's ideal for working with large spatial data cubes such as those generated by imaging spectrometers.

##About This Activity
In this activity we will explore reading a HDF5 data into R that contains spatial raster data.  Before going any further, please be sure that you have version 2.10 of rhdf5 installed. Use: `packageVersion("rhdf5")` to check the package version. If you need to update `rhdf5`, use the following code:

	source("http://bioconductor.org/biocLite.R")
	biocLite("rhdf5")

> Note: to update all packages use update.packages().


##1. Read Hdf5 data into R
We will use the raster and the rhdf5 libraries to read in the hdf5 data that contains hyperspectral data for the San Joaquin NEON field site in Domain 17.  
 
    #r Load `raster` and `rhdf5` packages and read NIS data into R
    library(raster)
    library(rhdf5)
    f <- '/path/to/your/data/SJER_140123_chip.h5'
    #look at the HDF5 file structure 
    h5ls(f,all=T)


Let's use the h5readAttributes function to pull metadata from the hdf5 file. 

    #r get spatial info and map info using the h5readAttributes function developed by Ted Hart
	spinfo <- h5readAttributes(f,"spatialInfo"))


Next, let's read in the wavelength center associated with each band in the hdf5 file. What wavelength is band 19 associated with? (hint: look at the wavelengths vector that we just imported and check out the data located at index 19)

>What this means: A band is simple a group of wavelengths. The imaging spectrometer collects reflected light energy in a pixel for light in that band - for example 800-805nm might be a band. Often when you get a multi or hyperspectral dataset, the band information is reported as the wavelength, which actually represents the center point value of the band AND the full width half max (FWHM) which represents the spread of the band around that center point. So, a band that covers 800-805nm might have a FWHM of 2.5 and a wavelength value of 802.5.

So now that we've gotten that out of the way - let's write some more code.


    #read in the wavelength information from the Hdf5 file
    wavelengths<- h5read(f,"wavelength",index=list(1:426,1))

Now - let's have a look at one of the bands. Each band in this hdf5 file represents a particular group of wavelengths. Let's check out the green band... which is band 34. For fun - ask R to tell you what wavelength value band 19 is. Slice up bands make a quick plot of the data.

    #r extract "slices" of data from an HDF5 file
	b34<- h5read(f,"Reflectance",index=list(1:477,1:502,34))

> **Arrays vs. Matrices - The Skinny**
> Arrays are matrices with more than 2 dimensions. Put the other way: matrices
> are arrays with only 2 dimensions.
> Arrays can have any number of dimensions including 1, 2, 3, etc.

    #Convert from array to matrix
    b34 <- b34[,,1]

Next, let's plot one band, to see what it looks like. Plotting spatial data as a visual "data check"is often a good idea - particularly when working in a non-gui environment like R or Python. 

    image(b34)


So the image, looks a bit hmmm it look a bit dark and the detail of the image is missing. What could be causing this? Let's have look at the distribution of reflectance values in our data.

    #View range of reflectance values.
    hist(b34,breaks=40,col="darkmagenta")
    hist(b34,breaks=40,col="darkmagenta",xlim = c(0, 5000))

What's going on towards the right of the plot? It looks like we have some pixels that are skewing how this renders.

    hist(b34, breaks=40,col="darkmagenta",xlim = c(5000, 15000),ylim=c(0,100))

From the metadata we know that 15000 is "no data" - let's set it to NA so R doesn't try to render those pixels
	
	b34[b34 > 14999] <- NA

Let's run a log on the values to try to factor out those high numbers. We will learn how to sharpen our data later.

	image(log((b34)))


so... now we have an image - but perhaps not quite oriented in the correct direction. This is because R reads in matrices starting from the upper left hand corner. Whereas, most rasters read pixels starting from the lower left hand corner. We can deal with this issue but creating a proper raster in R that will read in pixels as other software like QGIS and ENVI do.

Let's try again but this time, let's flip the order of things

    #r slicing - try two
	b34_2<- h5read(f,"Reflectance",index=list(1:477,502:1,34))

	#Convert from array to matrix
	b34_2 <- t(b34_2[,,1])
	image(log(t(b34_2)))

The results of the code above creates an image that looks a bit more like the image that we want to see.

##Create a Georeferenced Raster
Next, let's create a meaningful raster, that is plotted in geographic space from our HDF5 data. To do this we need to know the coordinate reference system (CRS), and the location of the first pixel (located in the lower left hand corner of the raster). We also need the resolution or size of each pixel in the data. 
NOTE that we are using the original matrix - b34 that we created above. if you remember correctly, this matrix is flipped along the Y axis. This is OK because the R raster function is smart enough to know to how to read in the data properly (starting at the lower left hand corner!). 

	#r create raster}
	b34r <- raster((b34))

## Now we need to grab the extent in a bounding box.  Luckily this is in the metadata,  We'll need it in the form of LL lon, UR lon, LL lat, UR lat

	ex <- sort(unlist(spinfo[2:5]))
	e <- extent(ex)
	extent(b34r) <- e
	plot(b34r)

What do you notice about the image above? The contrast in the image is low. What could be causing this?


Awesome! Now  we've plotted one band in geographic space. Try plotting some other bands and see what it looks like. Notice that the images that we plot lack contrast... we'll get to that next!

Now, let's try and generate a full color image with the RGB bands.  But before we start, let's write a function to handle some of the basic cleaning we did earlier, that way we can bulk process bands.


	#r RGB}
	# f: the hdf file
	# band: the band you want to grab
	# returns: a cleaned up HDF5 reflectance file
	getBandMat <- function(f, band){
  	  out<- h5read(f,"Reflectance",index=list(1:477,1:502,band))
  	  #Convert from array to matrix
  	  out <- t(out[,,1])
  	  out[out > 14999] <- NA
  	  return(out)
	}
	band2rast <- function(f,band){

	out <-  raster(getBandMat(f,band),crs="+zone=11N +ellps=WGS84 +datum=WGS84 +proj=longlat")

	ex <- sort(unlist(spinfo[2:5]))

If you want to stay in UTM's you can use the code below and comment out the two lines above. Note that these were calculated externally and not embedded in the metadata. In the future they will be embedded in the metadata of NEON HDF5 files.

	#out <-  raster(getBandMat(f,band),crs="+zone=11 +units=m +ellps=WGS84 +datum=WGS84 +proj=utm")
	# ex <- c(256521.0,256998.0,4112069.0,4112571.0)
	e <- extent(ex)
  	extent(out) <- e
  	return(out)
	}


	stackList <- function(rastList){
  	## Creates a stack of rasters from a list of rasters
  	masterRaster <- stack(rastList[[1]])
  	for(i in 2:length(rastList)){
    		masterRaster<-  addLayer(masterRaster,rastList[[i]])
  	}
  	return(masterRaster)
	}

	rgb <- list(58,34,19)
	rgb_rast <- lapply(rgb,band2rast, f = f)

Add the names of the bands so we can easily keep track of the bands in the list

	names(rgb_rast) <- as.character(rgb)

	### Check with a plot
	plot(rgb_rast[[1]])
	rgb_stack <- stackList(rgb_rast)
	plot(rgb_stack)
	plotRGB(rgb_stack,r=1,g=2,b=3, scale=300, stretch = "Lin")


	writeRaster(rgb_stack,file="test6.tif",overwrite=TRUE)

**a note about image stretching** 
notice that hte scale is set to 300 on the RGB image that we plotted above. We can adjust this number and notice that the image gets darker - or lighter

If you want to play around a bit with this -- try plotting the RGB image using different bands. Here are some suggestions.
* Color Infrared / False Color: rgb: (90,34,19)
* SWIR, NIR,Red Band -- rgb (152,90,58)

More on Band Combinations: [http://gdsc.nlr.nl/gdsc/en/information/earth_observation/band_combinations](http://gdsc.nlr.nl/gdsc/en/information/earth_observation/band_combinations)

We can also plot our image on a map of the US

	#Create a Map in R
	library(maps)
	map(database="state",region="california")
	points(spinfo$LL_lat~spinfo$LL_lon,pch = 15)
	# Add raster

Now the fun stuff!  Let's create NDVI or Normalized Difference Vegetation Index
NDVI is simply a ration between the Near infrared portion of the spectrum and the red. Please keep in mind the there are different ways to aggregate bands when using hyperspectral data. We are just showing you how the do the math. This is not necessarily the best way to calculate NDVI using hyperspectral data! 

	#r ndvi}

	ndvi_bands <- c(58,90)

	ndvi_rast <- lapply(ndvi_bands,band2rast, f = f)
	ndvi_stack <- stackList(ndvi_rast)
	NDVI <- function(x) {
  	  (x[,2]-x[,1])/(x[,2]+x[,1])
	}
	ndvi_calc <- calc(ndvi_stack,NDVI)
	plot(ndvi_calc)



  
