---
layout: post
title: "R: Working with HDF5 Format Hyperspectral Remote Sensing Data in in R"
date:   2014-11-17 20:49:52
authors: Edmund Hart, Leah A. Wasser
categories: [remote-sensing]
category: remote-sensing
tags: [hyperspectral-remote-sensing,R,HDF5]
mainTag: hyperspectral-imaging
description: "Open up and explore hyperspectral imagery in HDF format R."
code1: 
image:
  feature: hierarchy_folder_purple.png
  credit: The Artistry of Colin Williams, NEON
  creditlink: http://www.neoninc.org
permalink: /HDF5/Imaging-Spectroscopy-HDF5-In-R/
---

<div id="objectives">
**R Skill Level:** intermediate


<h3>Goals / Objectives</h3>
After completing this activity, you will:
<ol>
<li>Understand how HDF5 data can be used to store spatial data and the associated benefits of this format when working with large spatial data cubes.</li>
<li>Know how to subset spatial data contained within HDF5 files.</li>
<li>Know how to extract several bands, create RGB images and perform Raster raster math.</li>
<li>Know how to export a final Geotiff (spatially projected) that can be used both in further analysis and in common GIS tools like QGIS.</li>
</ol>

<h3>What you'll Need</h3>
<p>R or R studio to write your code.</p>

<h3>Data to Download</h3>
Be sure to download the NEON Imaging Spectrometer data subset. These data were collected
over the San Joachim field site located in California (NEON Domain 17). 

put link to the HDF5 file on the server here...

</div>


##About Imaging Spectroscopy (hyperspectral) remote sensing data

The electromagnetic spectrum is composed of thousands of bands representing different types of light energy. Imaging spectrometers break the electromagnetic spectrum into groups of bands that support classification of objects by their spectral properties on the earth's surface. Hyperspectral data consists of many bands - up to hundreds of bands - that cover the electromagnetic spectrum.

The NEON imaging spectrometer (NIS) collects data within the 3XXnm to 25XXnm of the electromagnetic spectrums within bands that are approximately 5nm in width. This results in a hyperspectral data cube that contains approximately 426 bands - which means BIG DATA. So big in fact that a X by X tile that cover xxx areas on the earth surface using 1 m pixels is already XXXmb in size.

The HDF5 file format supports not only temporal data, it also supports spatial data. And it's ideal for working with large spatial data cubes such as those generated by imaging spectrometers.

##About This Activity
In this activity we will exploring reading HDF5 data into R that contains spatial data. 



##P1. Read Hdf5 data into R
We will use the raster and the rhdf5 libraries to read in the hdf5 data that contains hyperspectral data for the San Joaquin NEON field site in Domain 17. We will also read in the h5metadata function which is a custom script that allows us to import metadata including the coordinate reference system into R. We will use this information to plot things and to perform the math.

><<look into this to make sure it's a universal function - not convinced that it is>>

    #r Load `raster` and `rhdf5` packages and read NIS data into R
    library(raster)
    library(rhdf5)
    f <- '/Users/lwasser/Documents/Conferences/1_DataWorkshop_ESA2014/HDF5File/SJER_140123_chip.h5'
    #look at the HDF5 file structure 
    h5ls(f,all=T)

Important: you can use functions that you've created in other R scripts without copying the code into your file. Just make sure to call the file that contains the function towards the top of the code (or before you call the function in the code).

    #make sure the hdf5 metadata function is loaded
                   source("/Users/lwasser/Documents/Conferences/1_DataWorkshop_ESA2014/hdf5_RCode/h5metadata.R")

Let's use our custom function to grab metadata from the hdf5 file. 

    #r get spatial info and map info
    spinfo <- h5metadata(f,"spatialInfo",11)


Next, let's read in the wavelength center associated with each band in the hdf5 file. What wavelength is band 19 associated with? (hint: look at the wavelengths vector that we just imported and check out the data located at index 19)

>What this means: A band is simple a group of wavelengths. The imaging spectrometer collects reflected light energy in a pixel for light in that band - for example 800-805nm might be a band. Often when you get a multi or hyperspectral dataset, the band information is reported as the wavelength, which actually represents the center point value of the band AND the full width half max (FWHM) which represents the spread of the band around that center point. So, a band that covers 800-805nm might have a FRWHM of 2.5 and a wavelength value of 802.5.

So now that we've gotten that out of the way - let's write some more code.


    #read in the wavelength information from the Hdf5 file
    wavelengths<- h5read(f,"wavelength",index=list(1:426,1))

Now - let's have a look at one of the bands. Each band in the hdf5 file represents a particular 
Let's check out the green band... which is band 34. For fun - ask R to tell you what wavelength value band 19 is.Slice up bands make a quick plot of the data.

```{r slicing}

b34<- h5read(f,"Reflectance",index=list(1:477,1:502,34))

> ##Arrays vs. Matrices - The Skinny
> Arrays are matrices with more than 2 dimensions. Put the other way: matrices
> are arrays with only 2 dimensions.
> Arrays can have any number of dimensions including 1, 2, 3, etc.

## Convert from array to matrix
b34 <- b34[,,1]

#let's plot one band, to see what it looks like ... 

image(b34)
#hmmm it look a bit fishy. let's look at the distribution of values
#let's have a look at the range of values in our data.
hist(b34,breaks=40,col="darkmagenta")
hist(b34,breaks=40,col="darkmagenta",xlim = c(0, 5000))

#what's going on towards the right of the plot? It looks like we have some pixels that are skewing how this renders
hist(b34, breaks=40,col="darkmagenta",xlim = c(5000, 15000),ylim=c(0,100))

#from the metadata we know that 15000 is "no data" - let's set it to NA so R doesn't try to render those pixels
b34[b34 > 14999] <- NA

#let's run a simple log on the values to try to factor out those high numbers just a bit. we will learn how to sharpen our data later.
image(log((b34)))

```

so... now we have an image - but perhaps not quite oriented in the correct direction. This is because R reads in matrices starting from the upper left hand corner. Whereas, most rasters read pixels starting from the lower left hand corner. We can deal with this issue but creating a proper raster in R that will read in pixels as other software like QGIS and ENVI do.

let's try again but this time, let's flip the order of things

```{r slicing - try two}

b34_2<- h5read(f,"Reflectance",index=list(1:477,502:1,34))
## Convert from array to matrix
b34_2 <- t(b34_2[,,1])
image(log(t(b34_2)))

#sweet! that looks a bit more like the image that we want to see
```


Ok, so now let's create a meaningful raster, that is plotted in geographic space from our data. to do this we need to know the coordinate reference system, and the location of the location of the first pixel (located in the lower left hand corner of the raster) we also need the resolution or size of each pixel in the data. Now NOTE that we are using the original matrix - b34 that we created above. if you remember correctly, this matrix is flipped along the Y axis. this is OK because the R raster function is smart enough to know to how to read in the data properly (starting at the lower left hand corner!). 

```{r create raster}
b34r <- raster((b34))

## Now we need to grab the extent in a bounding box.  Luckily this is in the metadata,  We'll need it in the form of LL lon, UR lon, LL lat, UR lat

ex <- sort(unlist(spinfo[2:5]))
e <- extent(ex)
extent(b34r) <- e
plot(b34r)
#hmmm... the image still looks faint... what could be causing that??

```

Awesome! Now  we've plotted one band in geographic space. Try plotting some other bands and see what it looks like. Notice that the images that we plot lack contrast... we'll get to that next!

Now, let's try and generate a full color image with the RGB bands.  But before we start, let's write a function to handle some of the basic cleaning we did earlier, that way we can bulk process bands.


```{r RGB}
# f: the hdf file
# band: the band you want to grab
# returns: a cleaned up HDF5 reflectance file
getBandMat <- function(f, band){
  out<- h5read(f,"Reflectance",index=list(1:477,1:502,band))
  ## Convert from array to matrix
  out <- t(out[,,1])
  out[out > 14999] <- NA
  return(out)
}
band2rast <- function(f,band){

out <-  raster(getBandMat(f,band),crs="+zone=11N +ellps=WGS84 +datum=WGS84 +proj=longlat")

  ex <- sort(unlist(spinfo[2:5]))
# If you want to stay in UTM's you can use the code below and comment out the two lines above. Note that these were calculated externally and not embedded in the metadata.  In the future they will be embedded in the metadata of NEON HDF5 files.

#out <-  raster(getBandMat(f,band),crs="+zone=11 +units=m +ellps=WGS84 +datum=WGS84 +proj=utm")
# ex <- c(256521.0,256998.0,4112069.0,4112571.0)
  e <- extent(ex)
  extent(out) <- e
  return(out)
}



stackList <- function(rastList){
  ## Creates a stack of rasters from a list of rasters
  masterRaster <- stack(rastList[[1]])
  for(i in 2:length(rastList)){
    masterRaster<-  addLayer(masterRaster,rastList[[i]])
  }
  return(masterRaster)
}

rgb <- list(58,34,19)
rgb_rast <- lapply(rgb,band2rast, f = f)
## Add the names of the bands so we can easily keep track of the bands in the list
names(rgb_rast) <- as.character(rgb)
### Check with a plot
plot(rgb_rast[[1]])
rgb_stack <- stackList(rgb_rast)
plot(rgb_stack)
plotRGB(rgb_stack,r=1,g=2,b=3, scale=300, stretch = "Lin")


writeRaster(rgb_stack,file="test6.tif",overwrite=TRUE)
```

**a note about image stretching** 
notice that hte scale is set to 300 on the RGB image that we plotted above. We can adjust this number and notice that the image gets darker - or lighter

If you want to play around a bit with this -- try plotting the RGB image using different bands. Here are some suggestions.
Color Infrared / False Color: rgb: (90,34,19)
SWIR, NIR,Red Band -- rgb (152,90,58)

More on Band Combinations: [http://gdsc.nlr.nl/gdsc/en/information/earth_observation/band_combinations](http://gdsc.nlr.nl/gdsc/en/information/earth_observation/band_combinations)

We can also plot our image on a map of the US

```{r mapping}
library(maps)
map(database="state",region="california")
points(spinfo$LL_lat~spinfo$LL_lon,pch = 15)
### Add raster
```

Now the fun stuff!  Let's create NDVI or Normalized Difference Vegetation Index
NDVI is simply a ration between the Near infrared portion of the spectrum and the red. Please keep in mind the there are different ways to aggregate bands when using hyperspectral data. We are just showing you how the do the math. This is not necessarily the best way to calculate NDVI using hyperspectral data! 

```{r ndvi}

ndvi_bands <- c(58,90)

ndvi_rast <- lapply(ndvi_bands,band2rast, f = f)
ndvi_stack <- stackList(ndvi_rast)
NDVI <- function(x) {
  (x[,2]-x[,1])/(x[,2]+x[,1])
}
ndvi_calc <- calc(ndvi_stack,NDVI)
plot(ndvi_calc)
```



  
